<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="css/github-pandoc.css" type="text/css" />
</head>
<body>
<h1 class="title">
First-Class Continuations on the Java Virtual Machine: An Implementation within the Kawa Scheme Compiler
</h1>
<h3>
MSc Thesis by Andrea Bernardini
</h3>
<h3>
Supervisor: Prof. Matteo Pradella
</h3>
<p></p>
<h1>Table of Contents</h1>
<div id="TOC">
<ul>
<li><a href="#abstract">Abstract</a></li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#context">Context</a><ul>
<li><a href="#functional-programming">Functional programming</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#scheme">Scheme</a></li>
<li><a href="#continuations">Continuations</a></li>
<li><a href="#kawa">Kawa</a></li>
</ul></li>
<li><a href="#thesis-contributions">Thesis Contributions</a></li>
<li><a href="#outline">Outline</a></li>
</ul></li>
<li><a href="#state-of-the-art">State of the art</a><ul>
<li><a href="#stack-based-implementation-techniques-for-first-class-continuations">Stack-based implementation techniques for first-class continuations</a><ul>
<li><a href="#the-garbage-collection-strategy">The garbage-collection strategy</a></li>
<li><a href="#the-spaghetti-strategy">The spaghetti strategy</a></li>
<li><a href="#the-heap-strategy">The heap strategy</a></li>
<li><a href="#the-stack-strategy">The stack strategy</a></li>
<li><a href="#the-chunked-stack-strategy">The chunked-stack strategy</a></li>
<li><a href="#the-stackheap-strategy">The stack/heap strategy</a></li>
<li><a href="#the-incremental-stackheap-strategy">The incremental stack/heap strategy</a></li>
<li><a href="#the-hieb-dybvig-bruggeman-strategy">The Hieb-Dybvig-Bruggeman strategy</a></li>
</ul></li>
<li><a href="#first-class-continuations-on-the-jvm">First-class continuations on the JVM</a><ul>
<li><a href="#heap-based-model">Heap based model</a></li>
<li><a href="#continuations-from-continuation-passing-style-transform">Continuations from continuation passing-style transform</a></li>
<li><a href="#continuations-from-generalized-stack-inspection">Continuations from generalized stack inspection</a></li>
<li><a href="#java-frameworks-implementing-continuations">Java frameworks implementing continuations</a></li>
<li><a href="#kawas-continuations">Kawa's continuations</a></li>
</ul></li>
</ul></li>
<li><a href="#implementing-first-class-continuations-on-the-jvm">Implementing first-class continuations on the JVM</a><ul>
<li><a href="#the-stack-manipulation-dilemma">The stack manipulation dilemma</a></li>
<li><a href="#a-solution-generalises-stack-inspection">A solution: generalises stack inspection</a></li>
<li><a href="#generalised-stack-inspection-for-a-jvm-based-scheme">Generalised stack inspection for a JVM-based Scheme</a><ul>
<li><a href="#assignment-conversion">Assignment conversion</a></li>
<li><a href="#a-normalization">A-Normalization</a></li>
<li><a href="#code-fragmentation">Code fragmentation</a></li>
<li><a href="#live-variable-analysis-and-closure-conversion">Live variable analysis and closure conversion</a></li>
<li><a href="#code-instrumentation">Code Instrumentation</a></li>
</ul></li>
<li><a href="#issues">Issues</a><ul>
<li><a href="#callcc-in-higher-order-functions"><code>call/cc</code> in higher order functions</a></li>
<li><a href="#code-size">Code size</a></li>
<li><a href="#integration">Integration</a></li>
</ul></li>
</ul></li>
<li><a href="#a-callcc-implementation-for-kawa">A call/cc implementation for Kawa</a><ul>
<li><a href="#an-instance-of-the-transformation-in-java">An instance of the transformation in Java</a><ul>
<li><a href="#exceptions-performance-in-java">Exceptions performance in Java</a></li>
</ul></li>
<li><a href="#support-code">Support code</a></li>
<li><a href="#a-brief-overview-of-kawas-compilation-process">A brief overview of Kawa's compilation process</a></li>
<li><a href="#a-normalization-1">A-Normalization</a></li>
<li><a href="#code-fragmentation-1">Code fragmentation</a></li>
<li><a href="#code-instrumentation-1">Code Instrumentation</a></li>
<li><a href="#other-control-operators-delimited-continuations">Other control operators: delimited continuations</a><ul>
<li><a href="#prompts-and-barriers">Prompts and barriers</a></li>
<li><a href="#shift-and-reset"><code>shift</code> and <code>reset</code></a></li>
<li><a href="#selective-transformation">Selective transformation</a></li>
</ul></li>
<li><a href="#higher-order-functions">Higher order functions</a></li>
</ul></li>
<li><a href="#case-studies">Case studies</a><ul>
<li><a href="#asynchronous-programming-async-and-await">Asynchronous programming: Async and Await</a><ul>
<li><a href="#coroutines">Coroutines</a></li>
<li><a href="#async-with-coroutines">Async with coroutines</a></li>
<li><a href="#async-with-threads">Async with threads</a></li>
</ul></li>
<li><a href="#kawa-debugger">Kawa debugger</a><ul>
<li><a href="#implementation-details">Implementation details</a></li>
</ul></li>
</ul></li>
<li><a href="#evaluation">Evaluation</a><ul>
<li><a href="#transformation-overhead">Transformation overhead</a></li>
<li><a href="#callcc-performance"><code>call/cc</code> performance</a></li>
<li><a href="#callcc-memory-usage"><code>call/cc</code> memory usage</a></li>
<li><a href="#code-size-1">Code size</a></li>
</ul></li>
<li><a href="#conclusions-and-future-work">Conclusions and future work</a><ul>
<li><a href="#future-work">Future work</a></li>
</ul></li>
</ul>
</div>
<h1 id="abstract">Abstract</h1>
<p>The widespread diffusion of the Java technology has encouraged the birth of new programming languages on the Java Virtual Machine, languages that brings new features to the Java environment, most of which taken from the functional paradigm. Kawa is an implementation of the programming language Scheme on the Java Virtual Machine. As a Scheme it provides a functional style of programming, dynamic typing, and meta-programming facilities. However, being the Java Virtual Machine devoid of stack manipulation primitives, Kawa lacks of one of the most peculiar Scheme features: First-class continuations.</p>
<p>This dissertation describes an implementation of the <code>call/cc</code> control operator in the Kawa compiler. In particular it shows how the exception handling feature, common to many programming languages, can be exploited to implement first-class continuations in an environment without stack manipulation primitives, and how this can be realised in a real compiler. This thesis also shows how first-class continuations and control operators like <code>call/cc</code> can be used to introduce concurrency features and to implement new control flow constructs in programming languages.</p>
<h1 id="acknowledgements">Acknowledgements</h1>
<p>I would like to thank the people who made this thesis possible.</p>
<p>I would like to thank my supervisor Prof. Matteo Pradella, for inspiring me with his course on programming languages, and then for giving me the opportunity to work on this thesis.</p>
<p>Special thanks are given to Per Bothner, the author and project leader of Kawa, for guiding me in the world of compiler programming. Without his help, this thesis would not have been possible.</p>
<p>My deepest gratitude goes to my family, for the continuous support during these years at university, and to my friends, for making this years unforgettable.</p>
<p></p>
<p></p>
<h1 id="introduction">Introduction</h1>
<blockquote>
<em>&quot;Programming languages are not just technology, but what programmers think in. They're half technology and half religion.&quot;</em>
<p class="citright">
Paul Graham, Beating the Averages
</p>
</blockquote>
<h2 id="context">Context</h2>
<h3 id="functional-programming">Functional programming</h3>
<p>It is well known that the modern computers are not improving their performance like in the past decades, because frequency scaling, for silicon, has reached a limit. For this reason, processors manufacturers increase the potential productivity of their products by adding cores <span class="citation">[<a href="#ref-TurnConcurrency2015">1</a>]</span>.</p>
<div class="figure">
<img src="figures/cpu-trends.png" alt="Intel CPU Trends [1] " />
<p class="caption">Intel CPU Trends <span class="citation">[<a href="#ref-TurnConcurrency2015">1</a>]</span> </p>
</div>
<p>This implies that to benefit most from this architecture, programs have to be parallellized. But parallel programming is quite harder than sequential programming, due to several new challenges it brings. <em>Functional programming</em> (FP) helps to get rid of some of these challenges, and it has recently risen in importance because it is well suited for parallel, concurrent and event-driven (or &quot;reactive&quot;) programming, thanks to the use of immutable variables and functions without side effects. The learning curve for functional programming is often steep, but parallel and concurrent programming with imperative languages is not intuitive and its learning curve might be even steeper.</p>
<p>Functional programming is often used in synergy with other programming paradigms, since the world is made of stateful objects, while FP uses a mainly stateless computation model. FP has ways to model state, but there is an essential mismatch in a stateless model trying to represent a stateful world.</p>
<p>However, there are several programming problems in the world that are easy to map to the FP model. Problems involving concurrency, parallelism, large data sets and multi-processing.</p>
<h3 id="java">Java</h3>
<p><em>Java</em> is a general-purpose programming language that is concurrent, class-based, object-oriented, and specifically designed to have as few implementation dependencies as possible. Java code can run on all platforms that support Java without the need for recompilation. Java applications are typically compiled to bytecode that can run on any <em>Java Virtual Machine</em> (JVM) regardless of computer architecture. As of 2015, Java is one of the most popular programming languages in use <span class="citation">[<a href="#ref-TIOBEIndex2015">2</a>]</span> (see Figures  and ). Java was originally developed by James Gosling at Sun Microsystems and released in 1995. The language derives much of its syntax from C and C++, but it has fewer low-level facilities than either of them <span class="citation">[<a href="#ref-JavaWiki2015">3</a>]</span>.</p>
<p>The reference implementation Java compilers, virtual machines, and class libraries were open-sourced in May 2007 under the GNU General Public License.</p>
<div class="figure">
<img src="figures/ranking.png" alt="TIOBE Index for June 2015 [2] " />
<p class="caption">TIOBE Index for June 2015 <span class="citation">[<a href="#ref-TIOBEIndex2015">2</a>]</span> </p>
</div>
<div class="figure">
<img src="figures/history_rank.png" alt="Positions of the top 10 programming languages of many years back. [2] " />
<p class="caption">Positions of the top 10 programming languages of many years back. <span class="citation">[<a href="#ref-TIOBEIndex2015">2</a>]</span> </p>
</div>
<h4 id="java-8">Java 8</h4>
<p>Starting from release 8, Java supports aspects of functional programming. Two core concepts introduced in Java 8 are <em>lambda expressions</em> and <em>functional interfaces</em> <span class="citation">[<a href="#ref-OracleLambda2015">4</a>]</span>.</p>
<p>A lambda expression is an anonymous function that can be declared with a comma separated list of the formal parameters enclosed in parentheses, an arrow token (-&gt;), and a body. Data types of the parameters can always be omitted, as can the parentheses if there is only one parameter. The body can consist of a single statement or a statement block.</p>
<p>Syntax:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    (arg1, arg2...) -&gt; { body }

    (type1 arg1, type2 arg2...) -&gt; { body }</code></pre></div>
<p>Examples:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    (<span class="dt">int</span> x, <span class="dt">int</span> y) -&gt; x + y

    () -&gt; <span class="dv">42</span>

    (String s) -&gt; { System.<span class="fu">out</span>.<span class="fu">println</span>(s); }

    () -&gt; { <span class="kw">return</span> <span class="fl">2.7182</span> };</code></pre></div>
<p>In Java, lambda expressions are represented as objects, and so they must be bound to a particular object type known as a functional interface. A functional interface is an interface that defines exactly one abstract method. An extremely valuable property of functional interfaces is that they can be instantiated using lambdas.</p>
<p>An example of a functional interface is <code>java.lang.Runnable</code>. It has only one method void <code>run()</code> declared. Before Java 8, anonymous inner classes were used to instantiate objects of functional interface. With Lambda expressions, this can be simplified.</p>
<p>Each lambda expression can be implicitly assigned to one functional interface. For example we can create <code>Runnable</code> interface’s reference from lambda expression like below:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    Runnable r = () -&gt; System.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;running&quot;</span>);</code></pre></div>
<p>This type of conversion is automatically handled by the compiler when we dont specify the functional interface. For example:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="kw">new</span> Thread(
        () -&gt; System.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;running&quot;</span>)
    ).<span class="fu">start</span>();</code></pre></div>
<p>In above code, compiler automatically deduced that lambda expression can be casted to Runnable interface from <code>Thread</code> class’s constructor signature <code>public Thread(Runnable r) { }</code>.</p>
<p>Few examples of lambda expressions and their functional interface:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    Consumer&lt;Integer&gt;  c = (<span class="dt">int</span> x) -&gt; { System.<span class="fu">out</span>.<span class="fu">println</span>(x) };

    BiConsumer&lt;Integer, String&gt; b = (Integer x, String y)
                                      -&gt; System.<span class="fu">out</span>.<span class="fu">println</span>(x + y);

    Predicate&lt;String&gt; p = (String s) -&gt; { s == <span class="kw">null</span> };</code></pre></div>
<p>With the addition of Lambda expressions to arrays operations, Java introduced a key concept into the language of <em>internal iteration</em>. Using that paradigm, the actual iteration over a collection on which a Lambda function is applied is now carried out by the core library itself <span class="citation">[<a href="#ref-WhyLambda2013">5</a>]</span>. An relevant possibility opened by this design pattern is to enable operations carried out on long arrays (such as sorting, filtering and mapping) to be carried out in parallel by the framework. For example:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    List&lt;Integer&gt; numbers = Arrays.<span class="fu">asList</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>);

    <span class="co">// old way</span>
    <span class="kw">for</span> (<span class="dt">int</span> number : numbers) {
        System.<span class="fu">out</span>.<span class="fu">println</span>(number);
    }

    <span class="co">// new way</span>
    numbers.<span class="fu">forEach</span>(value -&gt; System.<span class="fu">out</span>.<span class="fu">println</span>(value));</code></pre></div>
<p>In Java 8 it is also possible to reference both a static and an instance method using the new <code>::</code> operator:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    numbers.<span class="fu">forEach</span>(System.<span class="fu">out</span>::println);</code></pre></div>
<p>Passing a lambda expression to another function allows to pass not only values but also behaviours and this enables to project more generic, flexible and reusable API. For instance declaring the following method:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">evaluate</span>(List&lt;integer&gt; list,
                         Predicate&lt;integer&gt; predicate) {
        <span class="kw">for</span>(Integer n: list)  {
            <span class="kw">if</span>(predicate.<span class="fu">test</span>(n)) {
                System.<span class="fu">out</span>.<span class="fu">println</span>(n + <span class="st">&quot; &quot;</span>);
            }
        }
    }</code></pre></div>
<p>we can use the <code>Predicate</code> functional interface to create a test and print the elements that pass the test:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    System.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Print all numbers:&quot;</span>);
    <span class="fu">evaluate</span>(numbers, (n)-&gt;<span class="kw">true</span>);

    System.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Print even numbers:&quot;</span>);
    <span class="fu">evaluate</span>(numbers, (n)-&gt; n%<span class="dv">2</span> == <span class="dv">0</span> );

    System.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Print odd numbers:&quot;</span>);
    <span class="fu">evaluate</span>(numbers, (n)-&gt; n%<span class="dv">2</span> == <span class="dv">1</span> );</code></pre></div>
<p>Java 8 brings to developers another interesting feature from functional programming: <em>Streams</em>, that is, lazy <em>evaluation</em>. Streams are a new abstraction that allows to process data in a declarative way:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    System.<span class="fu">out</span>.<span class="fu">println</span>(
        numbers.<span class="fu">stream</span>()
            .<span class="fu">filter</span>(Lazy::isEven)
            .<span class="fu">map</span>(Lazy::doubleIt)
            .<span class="fu">filter</span>(Lazy::isGreaterThan5)
            .<span class="fu">findFirst</span>()
    );</code></pre></div>
<p>You can create a Stream from any Collection by invoking the <code>stream()</code> method on it. A Stream provides an interface to a sequenced set of values of a specific element type. However, streams don’t actually store elements; they are computed on demand. They consume from a data-providing source such as collections, arrays, or I/O resources and support common operations, such as filter, map, reduce, find, match, sorted. Furthermore, many stream operations return a stream themselves. This allows operations to be chained to form a larger pipeline, enabling also certain optimisations.</p>
<h4 id="the-java-virtual-machine">The Java Virtual Machine</h4>
<p>A Java Virtual Machine (JVM) is an abstract computing machine defined by a specification. The specification formally describes what is required of a JVM implementation. Having a single specification ensures all implementations are interoperable. A JVM implementation is a software platform that meets the requirements of the JVM specification in a compliant and preferably performant manner <span class="citation">[<a href="#ref-JVMWiki2015">6</a>]</span>.</p>
<p>One of the main goals of Java design is portability, and Java is indeed platform independent. That is achieved by compiling the Java language code to an intermediate representation called Java bytecode, instead of directly to architecture-specific machine code. Java bytecode instructions are analogous to machine code, but they are intended to be executed by a virtual machine written specifically for the host hardware. Moreover, Just-in-Time (JIT) compilers were introduced from an early stage that compile bytecodes to machine code during runtime. Thus a JVM is platform dependent, because it must convert Java bytecode into machine language which depends on the architecture and operating system being used. End users commonly use a Java Runtime Environment (JRE) installed on their own machine for standalone Java applications, or in a web browser for Java applets <span class="citation">[<a href="#ref-JavaWiki2015">3</a>]</span>.</p>
<p>The Oracle Corporation, which owns the Java trademark, distributes the Java Virtual Machine implementation HotSpot together with an implementation of the Java Class Library under the name Java Runtime Environment (JRE).</p>
<h4 id="jvm-based-languages">JVM based Languages</h4>
<p>The JVM is not only for Java. Several hundred JVM programming languages are available to be run on it. These languages ultimately compile to bytecode in class files, which the JVM can then execute.</p>
<p>Some JVM languages include more features than Java and aim to let developers write code in a more concise way. Features like collection literals, pattern matching, and a more sophisticated type inference were the motivation for languages such as Scala, Groovy, Xtend, Ceylon, Kotlin, and Fantom <span class="citation">[<a href="#ref-JVMLang2015">7</a>]</span>.</p>
<p>Then there are existing languages that were ported to the JVM. Python, Erlang, Ruby, Scheme and Javascript, for instance, all have an implementation targeting the JVM (respectively Jython, Erjang, JRuby, Kawa and Rhino). Another popular language ported to the JVM is Clojure, a dialect of Lisp with an emphasis on functional and concurrent programming <span class="citation">[<a href="#ref-JVMWiki2015">6</a>]</span>.</p>
<p>Many less-known JVM languages implement new research ideas, are suited only for a specific domain, or are just experimental.</p>
<h3 id="scheme">Scheme</h3>
<p><em>Scheme</em> is a dialect of the computer programming language Lisp. It follows a minimalist design philosophy that specifies a small standard core accompanied by powerful tools for meta-programming.</p>
<p>Scheme was created during the 1970s at the MIT AI Lab by Guy L. Steele and Gerald Jay Sussman. It was the first dialect of Lisp to choose lexical scope and the first to require implementations to perform tail-call optimisation. It was also one of the first programming languages to support first-class continuations <span class="citation">[<a href="#ref-SchemeWiki2015">8</a>]</span>.</p>
<p>Scheme is a general-purpose computer programming language. It is a high-level language, supporting operations on structured data such as strings, lists, and vectors, as well as operations on more traditional data such as numbers and characters. Scheme is a fairly simple language to learn, since it is based on a handful of syntactic forms and semantic concepts and since the interactive nature of most implementations encourages experimentation <span class="citation">[<a href="#ref-dybvig2009scheme">9</a>]</span>.</p>
<p>The storage required to hold the contents of an object is dynamically allocated as necessary and retained until no longer needed, then automatically deallocated, typically by a garbage collector. Simple atomic values, such as small integers, characters, booleans, and the empty list, are represented as primitive types and thus incur no allocation or deallocation overhead <span class="citation">[<a href="#ref-dybvig2009scheme">9</a>]</span>.</p>
<p>Scheme is <em>homoiconic</em>, i.e, programs share a common representation with Scheme data structures. As a result, any Scheme program has an internal representation as a Scheme object. For example, variables and syntactic keywords correspond to symbols, while structured syntactic forms correspond to lists. This representation is the basis for the syntactic extension facilities provided by Scheme for the definition of new syntactic forms. It also facilitates the implementation of interpreters, compilers, and other program transformation tools <span class="citation">[<a href="#ref-dybvig2009scheme">9</a>]</span>.</p>
<p>In Scheme, a procedure definition may appear within another block or procedure, and the procedure may be invoked at any time thereafter, even if the enclosing block has completed its execution. To support lexical scoping, a procedure carries the lexical context (environment) along with its code.</p>
<p>Furthermore orover, Scheme provides anonymous procedures. Indeed procedures are first-class data objects like strings or numbers, and variables are bound to procedures in the same way they are bound to other objects.</p>
<p>The Scheme language is standardized in the Revised Report on the Algorithmic Language Scheme (RnRS), where the  indicates the revision number. The last report is R7RS, released in 2013.</p>
<h4 id="scheme-basics">Scheme basics</h4>
<p>Scheme syntax is essential, it provides a minimal set of special forms: define, quote, lambda, cond, let/let*</p>
<p><code>define</code> is used to define new names.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">define</span><span class="fu"> x </span><span class="dv">10</span>)
    (<span class="kw">define</span><span class="fu"> square </span>(<span class="kw">lambda</span> (x) (* x x)))</code></pre></div>
<p><code>quote</code> prevents the argument to be evaluated as an expression, returning it as literal data (symbols or lists).</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (quote hi!)           <span class="kw">=&gt;</span> hi!
    (quote (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>))         <span class="kw">=&gt;</span> (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)

    <span class="co">; the tick-mark &#39; is syntactic sugar</span>
    &#39;(<span class="dv">1</span> <span class="dv">2</span> foo bar)          <span class="kw">=&gt;</span> (<span class="dv">1</span> <span class="dv">2</span> foo bar)</code></pre></div>
<p><code>lambda</code> is used to create anonymous functions.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">lambda</span> (x) (* x <span class="dv">10</span>)                   <span class="co">; anonymous function</span>
    (<span class="kw">define</span><span class="fu"> times10 </span>(<span class="kw">lambda</span> (x) (* x <span class="dv">10</span>))) <span class="co">; named the function now</span></code></pre></div>
<p><code>cond</code> is a general conditional.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">cond</span>
      ((<span class="kw">eq?</span> &#39;foo &#39;bar) &#39;hello)
      ((<span class="kw">=</span> <span class="dv">10</span> <span class="dv">20</span>) &#39;goodbye)
      (<span class="kw">else</span> &#39;sorry))                  <span class="kw">=&gt;</span> sorry</code></pre></div>
<p><code>let</code> is used to declare/use temporary variables.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">let</span> ((x <span class="dv">10</span>)
          (y <span class="dv">20</span>))
      (<span class="kw">+</span> x y))</code></pre></div>
<p>Built-in types are integers, rationals, floats, characters, strings, booleans, symbols, lists, and vectors. A set of built-in functions we can use on these types:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    <span class="co">;; arithmetic:  +, -, *, /</span>
    <span class="co">;; relational: &lt;, &lt;=, &gt;, &gt;=, =</span>
    (<span class="kw">+</span> <span class="dv">1</span> <span class="dv">2</span>)                    <span class="kw">=&gt;</span> <span class="dv">3</span>
    (<span class="kw">=</span> <span class="dv">1</span> <span class="dv">2</span>)                    <span class="kw">=&gt;</span> <span class="dv">#f</span> <span class="co">; &#39;=&#39; is for numbers</span></code></pre></div>
<p>Equality and identity tests:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">eq?</span> &#39;hello &#39;goodbye)      <span class="kw">=&gt;</span> <span class="dv">#f</span> <span class="co">; eq? is an identity test</span>
    (<span class="kw">eq?</span> &#39;hello &#39;hello)        <span class="kw">=&gt;</span> <span class="dv">#t</span>
    (<span class="kw">eq?</span> &#39;(<span class="dv">1</span> <span class="dv">2</span>) &#39;(<span class="dv">1</span> <span class="dv">2</span>))        <span class="kw">=&gt;</span> <span class="dv">#f</span>
    (<span class="kw">define</span><span class="fu"> foo </span>&#39;(<span class="dv">1</span> <span class="dv">2</span>))
    (<span class="kw">define</span><span class="fu"> bar </span>foo)
    (<span class="kw">eq?</span> foo bar)              <span class="kw">=&gt;</span> <span class="dv">#t</span>
    (<span class="kw">equal?</span> foo bar)           <span class="kw">=&gt;</span> <span class="dv">#t</span> <span class="co">; equality: they look the same</span>
    (<span class="kw">equal?</span> foo &#39;(<span class="dv">1</span> <span class="dv">2</span>))        <span class="kw">=&gt;</span> <span class="dv">#t</span></code></pre></div>
<p>Being a dialect of Lisp, Scheme provides a set of built-in functions for List manipulation: cons, car, and cdr.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    <span class="co">;; Three equivalent ways to create the list (1 2 3),</span>
    <span class="co">;; calling it foo</span>
    (<span class="kw">define</span><span class="fu"> foo </span>&#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>))
    (<span class="kw">define</span><span class="fu"> foo </span>(<span class="kw">cons</span> <span class="dv">1</span> (<span class="kw">cons</span> <span class="dv">2</span> (<span class="kw">cons</span> <span class="dv">3</span> ()))))
    (<span class="kw">define</span><span class="fu"> foo </span>(<span class="kw">list</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>))

    <span class="co">;; list precessing</span>
    (<span class="kw">null?</span> &#39;(<span class="dv">1</span> <span class="dv">2</span>))             <span class="kw">=&gt;</span> <span class="dv">#f</span>
    (<span class="kw">null?</span> ())                 <span class="kw">=&gt;</span> <span class="dv">#t</span>
    (<span class="kw">car</span> &#39;(<span class="dv">1</span> <span class="dv">2</span>))               <span class="kw">=&gt;</span> <span class="dv">1</span>
    (<span class="kw">cdr</span> &#39;(<span class="dv">1</span> <span class="dv">2</span>))               <span class="kw">=&gt;</span> (<span class="dv">2</span>)</code></pre></div>
<p>Iteration via recursion:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    <span class="co">;; Exponentiation function x^n</span>
    (<span class="kw">define</span><span class="fu"> </span>(<span class="kw">expt</span> x n
      (<span class="kw">if</span> (<span class="kw">=</span> n <span class="dv">0</span>)
          <span class="dv">1</span>
          (* x (<span class="kw">expt</span> x (<span class="kw">-</span> n <span class="dv">1</span>))))))

    <span class="co">;; List length</span>
    (<span class="kw">define</span><span class="fu"> </span>(<span class="kw">length</span> lst
      (<span class="kw">if</span> (<span class="kw">null?</span> lst)
          <span class="dv">0</span>
          (<span class="kw">+</span> <span class="dv">1</span> (<span class="kw">length</span> (<span class="kw">cdr</span> lst))))))</code></pre></div>
<p>It is straightforward to create and use higher order functions. Indeed functions are first-class in Scheme, they can be passed as arguments to other functions:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">define</span><span class="fu"> compose</span>
      (<span class="kw">lambda</span> (f g x)
        (f (g x))))

    (compose <span class="kw">even?</span> (<span class="kw">lambda</span> (x) (<span class="kw">-</span> x <span class="dv">1</span>)) <span class="dv">10</span>)   <span class="kw">=&gt;</span> <span class="dv">#f</span>

    <span class="co">;; takes a function and applies it to every element of a list</span>
    (<span class="kw">define</span><span class="fu"> </span>(map f lst)
      (<span class="kw">let</span> loop ((newlst lst))
        (<span class="kw">cond</span> ((<span class="kw">pair?</span> newlst)
          (<span class="kw">cons</span> (f (<span class="kw">car</span> newlst)) (loop (<span class="kw">cdr</span> newlst))))
         ((<span class="kw">null?</span> newlst)
          &#39;())
         (<span class="kw">else</span>
          (error <span class="st">&quot;second argument is not a list:&quot;</span>  lst)))))

    (map <span class="kw">even?</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))        <span class="kw">=&gt;</span> (<span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span>)</code></pre></div>
<h3 id="continuations">Continuations</h3>
<p>Computer programs usually control the flow of execution via procedure calls and returns; a stack of frames is how high-level programming languages keep track of the point to which each active subroutine should return control when it finishes executing. However, to solve real-world problems, procedure call and primitive expressions are not enough. Thus most high-level programming languages also provide other control-flow primitives, like conditionals, loops, and exception handling.</p>
<p>Scheme also supports <em>first-class continuations</em>. A continuation is a Scheme function that embodies “the rest of the computation”. The continuation of any Scheme expression determines what is to be done with its value. This continuation is always present, in any language implementation, since the system is able to continue from each point of the computation. Scheme provides a mechanism for capturing this continuation as a closure. The obtained continuation can be used to continue, or resume, the computation from the point it was captured, whether or not the computation has previously completed. This is useful for nonlocal exits in handling exceptions, or in the implementation of complex control structures such as coroutines or generators <span class="citation">[<a href="#ref-dybvig1987three">10</a>]</span>.</p>
<p>Considering a computation such as <code>(* (+ 2 4) (+ 1 6))</code>, there are several continuations involved. The continuation for <code>(+ 2 4)</code> can be expressed in this way: take this value (6), keep it aside; now add one and six, take the result and multiply it with the value we had kept aside; then finish. The continuation for <code>(+ 1 6)</code> means: take this value, multiply it with the value (6) that was previously kept aside; then finish. Notice in particular how the result of <code>(+ 2 4)</code> is part of the continuation of <code>(+ 1 6)</code>, because it has been calculated and kept aside. Continuations are not static entities that can be determined at compile time: they are dynamic objects that are created and invoked during program execution.</p>
<p>Using the syntactic form <code>call-with-current-continuation</code> (usually abbreviated <code>call/cc</code>), a program can obtain its own continuation. This continuation is a Scheme closure that may be invoked at any time to continue the computation from the point of the <code>call/cc</code>. It may be invoked before or after the computation returns; it may be invoked more than one time.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<p>The standard idiom for <code>call/cc</code> has an explicit lambda term as its argument:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">call/cc</span> (<span class="kw">lambda</span> (current-continuation)
      body))</code></pre></div>
<p>During the execution of the expression body, the variable current-continuation is bound to the current continuation. If invoked, current-continuation immediately returns from the call to <code>call/cc</code>, and <code>call/cc</code> returns whatever value was passed to current-continuation.</p>
<p>When applied to a function <code>f</code>, <code>call/cc</code> captures and aborts the entire continuation <code>k</code>, reinstate a copy of <code>k</code>, and applies <code>f</code> to <code>k</code>.</p>
<p>Consider a first example:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">call/cc</span>
      (<span class="kw">lambda</span> (k)
        (k <span class="dv">42</span>)))</code></pre></div>
<p>This applies <code>call/cc</code> to the function <code>(lambda (k) (k 42))</code>, which is called with argument <code>k</code>, the current continuation. Being the body of the function <code>(k 42)</code>, the continuation is thrown the value 42. This makes the <code>call/cc</code> return the value 42. Hence, the entire expression evaluates to 42.</p>
<p>Now consider</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">call/cc</span>
      (<span class="kw">lambda</span> (k)
        (<span class="kw">+</span> (k <span class="dv">42</span>) <span class="dv">100</span>)))</code></pre></div>
<p>In this case, the function throws the value 42 to the continuation, but there is another computation afterwards. That computation has no effect, because when a continuation is invoked with a value, the program reinstates the invoked continuation, and the continuation which was going to take a value <code>x</code> and perform <code>(+ x 100)</code> has been aborted. The result is still 42.</p>
<p>On the other hand, consider</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">call/cc</span>
      (<span class="kw">lambda</span> (k) <span class="dv">42</span>))</code></pre></div>
<p>Here, the function applied by <code>call/cc</code> does not make use of the current continuation. It performs a real return, with the value 42.</p>
<p>Actually, although a continuation can be called as a procedure, it is not a real function, which takes a value and returns another. An invoked continuation takes a value and does everything that follows to it, never returning a value to the caller.</p>
<p>As an other example, consider the following code:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">display</span>
        (<span class="kw">call/cc</span> (<span class="kw">lambda</span> (k)
              (<span class="kw">display</span> <span class="st">&quot;This is executed.\n&quot;</span>)
              (k <span class="st">&quot;Value passed to the continuation.\n&quot;</span>)
              (<span class="kw">display</span> <span class="st">&quot;But not this.\n&quot;</span>))))</code></pre></div>
<p>it will display:</p>
<pre><code>    This is executed.
    Value passed to the continuation.</code></pre>
<p>An interesting feature of first-class continuations is that the continuation may still be called even after the call to call/cc is finished. When applied to a value <code>v</code>, a continuation <code>k</code> aborts its entire execution context, reinstates <code>k</code> as the current entire continuation, and returns the value <code>v</code> to the continuations <code>k</code>, which is &quot;waiting for a value” in order to perform some computation with it. In some Scheme implementations, the value passed to a continuation can be a void one.</p>
<p>For example, the following causes an infinite loop that prints <code>goto start</code> forever:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">let</span> ((start <span class="dv">#f</span>))
      (<span class="kw">if</span> (<span class="kw">not</span> start)
        (<span class="kw">call/cc</span> (<span class="kw">lambda</span> (cc)
                   (set! start cc))))

      (<span class="kw">display</span> <span class="st">&quot;goto start\n&quot;</span>)
      (start))</code></pre></div>
<h4 id="delimited-continuations">Delimited Continuations</h4>
<p>Continuations captured by <code>call/cc</code> is the whole continuation that includes all the future computation. In some cases, we want to manipulate only a part of computation. This is possible with a kind of continuations called <em>delimited</em> or <em>composable</em> continuations <span class="citation">[<a href="#ref-Asai2011">14</a>]</span>.</p>
<p>A continuation is delimited when it produces an intermediate answer rather than the final outcome of the entire computation. In other words, a delimited continuation is a representation of the &quot;rest of the computation&quot; from the current computation up to a designated boundary. Unlike regular continuations, delimited continuations return a value, and thus may be reused and composed <span class="citation">[<a href="#ref-kiselyov2007delimited">15</a>]</span>.</p>
<p>Various operators for delimited continuations have been proposed in the research literature, such as <code>prompt</code> and <code>control</code>, <code>shift</code> and <code>reset</code>, <code>cupto</code>, <code>fcontrol</code>, and others <span class="citation">[<a href="#ref-RacketContinuations2015">16</a>]</span>. In this introduction we will consider only the <code>shift</code> and <code>reset</code> operators.</p>
<p>The <code>reset</code> operator sets the limit for the continuation while the <code>shift</code> operator captures or reifies the current continuation up to the innermost enclosing <code>reset</code>. The <code>shift</code> operator passes the captured continuation to its body, which can invoke, return or ignore it. Whatever result that <code>shift</code> produces is provided to the innermost <code>reset</code>, discarding the continuation in between the <code>reset</code> and <code>shift</code>. The continuation, if invoked, effectively reinstates the entire computation up to the <code>reset</code>. When the computation is completed, the result is returned by the delimited continuation <span class="citation">[<a href="#ref-DelimitedWiki2015">17</a>]</span>. For example, consider the following snippet in Scheme:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (* <span class="dv">2</span> (reset (<span class="kw">+</span> <span class="dv">1</span> (shift k (k <span class="dv">5</span>)))))</code></pre></div>
<p>The <code>reset</code> delimits the continuation that <code>shift</code> captures. When this code is executed, the use of <code>shift</code> will bind <code>k</code> to the continuation <code>(+ 1 [])</code> where <code>[]</code> represents the part of the computation that is to be filled with a value. This is exactly the code that surrounds the <code>shift</code> up to the <code>reset</code>. Since the body of <code>shift</code> immediately invokes the continuation, the previous expression is equivalent to the following:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (* <span class="dv">2</span> (<span class="kw">+</span> <span class="dv">1</span> <span class="dv">5</span>))</code></pre></div>
<p>Once the execution of the <code>shift</code>'s body is completed, the continuation is discarded, and execution restarts outside <code>reset</code>. For instance:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (reset (* <span class="dv">2</span> (shift k (k (k <span class="dv">4</span>)))))</code></pre></div>
<p>invokes <code>(k 4)</code> first, which produces 8 as result, and then <code>(k 8)</code>, which returns 16. At this point, the <code>shift</code> expression has terminated, and the rest of the <code>reset</code> expression is discarded. Therefore, the final result is 16.</p>
<h3 id="kawa">Kawa</h3>
<p><em>Kawa</em> is a language framework written in Java that implements an extended version of the programming language Scheme. It provides a set of Java classes useful for implementing dynamic languages, such as those in the Lisp family. Kawa is also an implementation of almost all of R7RS Scheme (First-class continuations being the major missing feature), and which compiles Scheme to the bytecode instructions of the JVM <span class="citation">[<a href="#ref-Kawa2015">18</a>]</span>. The author and project leader of Kawa is Per Bothner, who started its development in 1996.</p>
<p>Kawa gives run-time performance a high priority. The language facilitates compiler analysis and optimisation, and most of the time the compiler knows which function is being called, so it can generate code to directly invoke a method. Kawa also tries to catch errors at compile time.</p>
<p>To aid with type inference and type checking, Kawa supports optional type specifiers, which are specified using two colons. For example:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">define</span><span class="fu"> </span>(add-int x::int y::int) :: String
        (String (<span class="kw">+</span> x y)))</code></pre></div>
<p>This defines a procedure add-int with two parameters: x and y are of type Java <code>int</code>; the return type is a <code>java.lang.String</code>.</p>
<p>The Kawa runtime start-up is quite fast for a language based on the JVM. This allows Kawa to avoid using an interpreter. Each expression typed into the REPL is compiled on-the-fly to JVM bytecodes, which may be compiled to native code by the just-in-time (JIT) compiler.</p>
<p>Kawa Scheme has several extensions for dealing with Java objects. It allows to call methods of Java objects/classes, create objects and implement classes and interfaces.</p>
<p>For example, the following is Kawa code for an instance of a anonymous class:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (object (&lt;java.lang.Runnable&gt;)
      ((run) &lt;void&gt;
       (<span class="kw">display</span> <span class="st">&quot;running!\n&quot;</span>)))</code></pre></div>
<p>Here a simple class definition:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (define-simple-class Person ()
      (last ::String)
      (first ::String)
      ((*init* f l)
       (set! first f)
       (set! last l))
      ((sayHello)
       (<span class="kw">display</span> <span class="st">&quot;Hello &quot;</span>)
       (<span class="kw">display</span> (<span class="kw">string-append</span> first
                               <span class="st">&quot; &quot;</span>
                               last
                               <span class="st">&quot;!\n&quot;</span>))))

    (<span class="kw">let</span> ((p (Person <span class="st">&quot;Alyssa&quot;</span> <span class="st">&quot;P. Hacker&quot;</span>)))
      (p:sayHello)) <span class="co">; =&gt; Hello Alyssa P. Hacker!</span></code></pre></div>
<h2 id="thesis-contributions">Thesis Contributions</h2>
<p>My main contribution is an implementation of <code>call/cc</code> in a Scheme compiler targeting the JVM. The only other Scheme implementations targeting the JVM are SISC, which is an heap based interpreter, and Bigloo, which is a compiler but does not support continuations in the JVM back-end. Scala implements a different type of control operator, <code>shift</code> and <code>reset</code>. Although Ruby has <code>callcc</code>, JRuby does not support it.</p>
<p>I address the problem of providing a control operator that copies the stack in an environment that prevents direct stack manipulation. Unlike other solutions proposed to implement continuations on the JVM, we perform a transformation on the syntax tree produced by Kawa, instead of a transformation at the bytecode level. This make our transformation independent of the JVM version.</p>
<p>I present a variant of generalised stack inspection, described by Pettyjohn et al., as an extension of the Kawa compiler. The transformation is global, thus has been developed as an optional compiler pass, to avoid adding overhead to programs that do not use continuations.</p>
<h2 id="outline">Outline</h2>
<p>The following chapters are organized as follows. Chapter 2 provides a survey of related work. It discusses common techniques for implementing <code>call/cc</code> present in literature. Then it also compares different approaches to implement first-class continuations on the JVM.</p>
<p>Chapter 3 presents the issues in delivering first-class continuations on the JVM. It describes the details of the code transformation technique employed to enable the capture and resume of first-class continuations.</p>
<p>Chapter 4 demonstrates the viability of the design by providing an implementation of the entire transformation.</p>
<p>Chapter 5 shows how the proposed implementation can be used to add debugging facilities to Kawa, and to implement new control flow constructs.</p>
<p>Chapter 6 provides a performance evaluation and discusses some issues related this approach. The advantages and limitations of this approach are also discussed in detail.</p>
<p>Finally, Chapter 7 summarizes the contributions of this thesis and discusses possible future work.</p>
<h1 id="state-of-the-art">State of the art</h1>
<blockquote>
<em>&quot;Objective reality is a synthetic construct, dealing with a hypothetical universalization of a multitude of subjective realities.&quot;</em>
<p class="citright">
Philip K. Dick, The Electric Ant
</p>
</blockquote>
<h2 id="stack-based-implementation-techniques-for-first-class-continuations">Stack-based implementation techniques for first-class continuations</h2>
<p>The most common approach to implement first-class continuations is to use a stack-based execution architecture and to reify the current continuation by making a copy of the stack, which is reinstated when the continuation is invoked. This is the approach taken by many language implementations that are in direct control of the runtime system. This section describes the most used implementation strategies for first class continuations.</p>
<h3 id="the-garbage-collection-strategy">The garbage-collection strategy</h3>
<p>The simplest strategy for ensuring that continuations have unlimited extent is to allocate them in the heap and to rely on garbage collection to recover their storage. This is called the gc strategy. The gc strategy is not a zero-overhead strategy and it is optimised for programs in which every continuation frame is captured. Few real programs capture all continuations, however, so the gc strategy may not perform as well as a zero-overhead strategy. The most important indirect cost of the gc strategy is that the compiler must allocate a separate continuation frame for each non-tail call, unless the compiler can prove that the continuation will not be captured during the non-tail call. The gc strategy also suffers more cache misses than the other strategies described in this section <span class="citation">[<a href="#ref-Clinger1999">19</a>]</span>.</p>
<h3 id="the-spaghetti-strategy">The spaghetti strategy</h3>
<p>This is a variation of the gc strategy. The spaghetti stack is in effect a separate heap in which storage is reclaimed by reference counting rather than garbage collection. Though complex, the spaghetti stack was at one time more efficient than using a gc strategy with a non-generational garbage collector, because the spaghetti stack’s storage management is optimised to support procedure call, return, and a host of related operations. When all frames have dynamic extent, the spaghetti stack behaves as a conventional stack. When a fast garbage collector is available, the spaghetti strategy is probably slower than the gc strategy. Moreover captures and throws require updating the reference counts, thus appears that the gc strategy should always perform better than the spaghetti strategy <span class="citation">[<a href="#ref-Clinger1999">19</a>]</span>.</p>
<h3 id="the-heap-strategy">The heap strategy</h3>
<p>In the heap strategy, a one-bit reference count in each frame indicates whether the frame has been captured. Continuation frames are allocated in a garbage-collected heap, as in the gc strategy, but a free list of uncaptured frames is also used. When a frame is needed by a procedure call, it is taken from the free list unless the free list is empty. If the free list is empty, then the frame is allocated from the heap. When a frame is returned through, it is linked onto the free list if its reference count indicates that it has not been captured. Otherwise it is left for the garbage collector to reclaim. The heap strategy is not a zero-overhead strategy and it is most practical if all continuation frames are the same size; otherwise multiple free lists may be required. This is an indirect cost of the heap strategy. Another indirect cost is that, like the gc strategy, the heap strategy makes it difficult to reuse a continuation frame for multiple non-tail calls <span class="citation">[<a href="#ref-Clinger1999">19</a>]</span>.</p>
<h3 id="the-stack-strategy">The stack strategy</h3>
<p>In the stack strategy, the active continuation is represented as a contiguous stack in an area of storage called the stack cache. Non-tail calls push continuation frames onto this stack cache, and returns pop frames from the stack cache, just as in an ordinary stack-based implementation. When a continuation is captured, however, a copy of the entire stack cache is made and stored in the heap. When a continuation is thrown to, the stack cache is cleared and the continuation is copied back into the stack cache. A first-class continuation thus resides in the heap, but is cached in the stack cache whenever it is the active continuation. The stack strategy is a zero-overhead strategy. Capturing, recapturing, and throwing to a continuation take time proportional to the size of the continuation. An indirect cost of the stack strategy is introduced by the fact that it repeatedly copies the same continuation from the stack cache to the heap. This can increase the asymptotic storage space required. The stack strategy prevents a compiler from allocating storage for mutable variables within a continuation frame, because there are other copies of it. Mutable variables must generally be allocated in registers or in the heap, that is another indirect cost of the stack strategy <span class="citation">[<a href="#ref-Clinger1999">19</a>]</span>.</p>
<h3 id="the-chunked-stack-strategy">The chunked-stack strategy</h3>
<p>By maintaining a small bound on the size of the stack cache, and copying portions of the stack cache into the heap or back again as the stack-cache overflows and underflows, the chunked-stack strategy reduces the worst-case latency of captures and throws. This strategy works well with generational garbage collection because limiting the size of the stack cache limits the size of the root set that the garbage collector must scan on each garbage collection. The portion of the continuation that resides in the heap will be scanned only when its generation is collected. The chunked-stack strategy is a zero-overhead strategy, because the cost of stack-cache overflows and underflows is usually negligible. On the other hand, the chunked-stack strategy requires a stack cache that is large enough to avoid stack-cache overflows and underflows, that degrade performance <span class="citation">[<a href="#ref-Clinger1999">19</a>]</span>.</p>
<h3 id="the-stackheap-strategy">The stack/heap strategy</h3>
<p>The stack/heap strategy is similar to the stack strategy. All continuation frames are allocated in the stack cache. When a continuation is captured, however, the contents of the stack cache are moved into the heap and the stack cache is cleared. When a continuation is thrown to, the new active continuation is left in the heap and the stack cache is cleared; this can be done in constant time. Since the current continuation may reside in either the stack cache or in the heap, each procedure return must test to see whether the frame should be popped off the stack cache. The stack/heap strategy makes throwing and recapturing a previously captured continuation very fast. A disadvantage of the stack/heap strategy is that it prevents the compiler from reusing a single continuation frame for multiple non-tail calls <span class="citation">[<a href="#ref-Clinger1999">19</a>]</span>.</p>
<h3 id="the-incremental-stackheap-strategy">The incremental stack/heap strategy</h3>
<p>The incremental stack/heap strategy is a variation of the stack/heap strategy: When returning through a continuation frame that isn’t in the stack cache, a trap occurs and copies the frame into the stack cache. The trap can be implemented by maintaining a permanent continuation frame at the bottom of the stack cache. This frame’s return address points to system code that copies one or more frames from the heap into the stack cache, and immediately returns through the first of those continuation frames. The incremental stack/heap strategy is a zero-overhead strategy, with the same calling sequence as the stack strategy. Since the incremental stack/heap strategy copies frames from the heap into the stack cache, mutable variables cannot be kept within a continuation frame <span class="citation">[<a href="#ref-Clinger1999">19</a>]</span>.</p>
<h3 id="the-hieb-dybvig-bruggeman-strategy">The Hieb-Dybvig-Bruggeman strategy</h3>
<p>A variation of the incremental stack/heap strategy that uses multiple stack segments that are allocated in the heap. The stack segment that contains the current continuation serves as the stack cache. When the stack cache overflows, a new stack cache is allocated and linked to the old one. Stack-cache underflow is handled by an underflow frame, as in the incremental stack/heap strategy. When a continuation is captured, the stack cache is split by allocating a small data structure representing the captured continuation. The data structure points to the current continuation frame within the stack cache. The unused portion of the stack cache becomes the new stack cache, and an underflow frame is installed at its base. A throw is handled as in the incremental stack/heap strategy: the current stack cache is cleared, and some number of continuation frames are copied into it. The underflow frame at the base of the stack cache is linked to the portion of the new continuation that was not copied. This is a zero-overhead strategy, in which mutable variables generally cannot be allocated within a continuation frame, but continuation frames may be reused for multiple non-tail calls <span class="citation">[<a href="#ref-Clinger1999">19</a>]</span>.</p>
<h2 id="first-class-continuations-on-the-jvm">First-class continuations on the JVM</h2>
<p>The implementations described in the previous section require to directly manipulate the stack, thus they are not suitable for being used on the Java Virtual Machine, which do not permit direct access or modification of stack contents. This section describes some implementation designed to implement first class continuations on the Java Virtual Machine.</p>
<h3 id="heap-based-model">Heap based model</h3>
<p>In a typical implementation of a programming language, a true stack is used to record call frames. Each call frame consists at least of a return address, variable bindings and a link to the previous frame. The variable bindings are the actual parameters and local variables used by the called procedure. A call frame is typically built by the calling procedure (caller). The caller pushes on the stack the actual parameters, a link to its stack frame and the return address, then jumps to the called procedure (callee). The callee augments the frame by pushing values of local variables. If the callee in turn calls another routine, it creates a new stack frame in the same way. When the callee has reached the end of its code, it returns to the caller by resetting the frame link, removing the frame, and jumping to the saved return address. The state of each active call is recorded on the stack, and it is destroyed once the call has been completed <span class="citation">[<a href="#ref-dybvig1987three">10</a>]</span>.</p>
<p>Because of restricted access of stack content on the JVM, for languages that support first-class continuations this structure is not sufficient. First-class continuations require heap allocation of the call frames as well as the environment. This is because the natural implementation of a continuation is to retain a pointer into the call stack. Because the continuation is a first-class object, there is no restriction on when it may be invoked. In particular, it may be invoked even after control has returned from the point where it was obtained. If so, the stack may have since grown, overwriting some of the stack frames in the continuation. The natural solution, then, is to maintain a linked list of heap-allocated stack frames. As the stack grows, a new frame is allocated in an unused portion of the heap so that the old stack frames remain intact <span class="citation">[<a href="#ref-dybvig1987three">10</a>]</span>.</p>
<p>The main disadvantage of heap allocation of call frames and environments is the overhead associated with the use of a heap. This overhead includes the additional cost of finding space in the heap when building the call frames and environments, the cost of storage reclamation to deallocate those frames and environments and the cost of following links instead of indexing a stack or frame pointer. The overhead also includes the indirect cost of using excessive amounts of memory. Furthermore, use of the heap rather than a stack prevents the use of some hardware-optimised or microcode-supported instructions for managing the stack <span class="citation">[<a href="#ref-dybvig1987three">10</a>]</span>.</p>
<p>The heap-based model has been used by several implementations, including Smalltalk, StacklessPython, Ruby, SML. On the JVM, this technique has been utilised by SISC <span class="citation">[<a href="#ref-Miller2002">20</a>]</span>, a fully R5RS compliant interpreter of Scheme, with proper tail-recursion and first-class continuations.</p>
<h3 id="continuations-from-continuation-passing-style-transform">Continuations from continuation passing-style transform</h3>
<p>An other approach to implement first-class continuations is to transform programs into continuation passing-style (CPS) <span class="citation">[<a href="#ref-appel2006compiling">21</a>, <a href="#ref-adams1986orbit">22</a>]</span>. The standard CPS-transform is a whole-program transformation, in which all explicit or implicit return statements are replaced by function calls and all state is kept in closures. One effect of CPS is that the stack is completely bypassed during execution, and this is not ideal for a stack-based architecture like the JVM.</p>
<p>Considering that manually written CPS code shows that only a small number of functions in a program actually need to pass along continuations, Tiark Rompf et al. developed a selective CPS transform for the Scala programming language <span class="citation">[<a href="#ref-Rompf2009">23</a>]</span> that is applied only where it is actually needed, and allows to maintain a stack-based runtime discipline for the majority of code. Thus, they made use of Scala’s pluggable typing facilities and introduce a type annotation, so that the CPS transform could be carried out by the compiler on the basis of expression types (i.e. it is type-directed). An advantage of this technique is that by design it avoids the performance problems associated with implementations of delimited continuations in terms of undelimited ones. However, there are some drawbacks. Because of the global transformation performed by the continuations compiler plugin, there are some control constructs that can not be used when calling a CPS function. For instance, using return statements in a CPS function may cause type mismatch compiler errors, thus is better to avoid using them. The compiler plugin does not handle <code>try</code> blocks, so it is not possible to catch exceptions within CPS code <span class="citation">[<a href="#ref-McBeath2010">24</a>]</span>.</p>
<p>There are also some issues with looping constructs. Capturing delimited continuations inside a while loop turns the loop into a general recursive function. Therefore each invocation of <code>shift</code> within a looping construct allocates another stack frame, so after many iterations it is possible to run into a stack overflow. Moreover, some looping constructs can not be used with a <code>shift</code> inside them, because everything on the call path between a <code>shift</code> and its enclosing <code>reset</code> must be CPS-transformed. That means that a <code>shift</code> cannot be used into the regular foreach, map and filter methods, because they are not CPS-transformed <span class="citation">[<a href="#ref-McBeath2010">24</a>]</span>.</p>
<h3 id="continuations-from-generalized-stack-inspection">Continuations from generalized stack inspection</h3>
<p>In <span class="citation">[<a href="#ref-Pettyjohn2005">25</a>]</span>, Pettyjohn et al. show how to translate a program into a form that allows it to capture and restore its own stack without requiring stack manipulation primitives. They demonstrate that the native exception handling mechanism can be used to propagate captured control state down the stack. Their work is an extension of previous work by Sekiguchi et al. <span class="citation">[<a href="#ref-Sekiguchi2001">26</a>]</span> and Tao <span class="citation">[<a href="#ref-tao2001portable">27</a>]</span>. Variants of this technique has been described in <span class="citation">[<a href="#ref-Loitsch2007">28</a>]</span> for JavaScript, in <span class="citation">[<a href="#ref-Marshall2009">29</a>]</span> for a Scheme interpreter targeting the .NET CLR and in Kilim <span class="citation">[<a href="#ref-Srinivasan2006">30</a>, <a href="#ref-Bolton2000">31</a>]</span>, a message-passing framework for Java. The basic idea is to break up the code into fragments (as top level methods) where the last instruction of any fragment is a call to the next fragment in the chain. To achieve this result, they have specialised continuation objects that maintain the state needed for each fragment and an overridden <code>Invoke</code> method to invoke the corresponding fragment. Each fragment knows exactly which fragment to invoke next <span class="citation">[<a href="#ref-Srinivasan2006">30</a>]</span>. The transform differs from continuation passing-style in that the call/return stack continues to be the primary mechanism for representing continuations; a heap representation of the continuation is only constructed when necessary. This may result in better performance than CPS-conversion for those programs that make only occasional use of first-class continuations <span class="citation">[<a href="#ref-StackHack2005">32</a>]</span>.</p>
<p>This transformation preserves the calling signature of a procedure, but it augments the behavior of the procedure when a continuation is to be captured <span class="citation">[<a href="#ref-StackHack2005">32</a>]</span>. We therefore introduce into each method an additional control path that extracts the dynamic state of the method and appends it to a data structure. To capture a continuation, we throw a special exception to return control to the method along the alternate control path. After appending the dynamic state, the method re-throws the exception. This causes the entire stack to be emptied and the corresponding chain of reified frames to be built. A handler installed at the base of the stack is the ultimate receiver of the exception and it creates a first-class continuation object in the heap using the chain of reified frames <span class="citation">[<a href="#ref-Marshall2009">29</a>]</span>.</p>
<p>This implementation technique is substantially equivalent to the stack strategy described in the first section of this chapter <span class="citation">[<a href="#ref-StackHack2005">32</a>]</span>. Moreover, it can nearly be a zero-overhead technique, for platforms in which exception handlers are not expensive, especially when no exception is thrown. This is the case for the Java Virtual Machine <span class="citation">[<a href="#ref-Longjumps2015">33</a>]</span>.</p>
<p>The process consists of six steps <span class="citation">[<a href="#ref-Marshall2009">29</a>, <a href="#ref-StackHack2005">32</a>]</span>:</p>
<ol style="list-style-type: decimal">
<li><p>Assignment Conversion - Capturing and re-instating a continuation will cause variables to be unbound and rebound multiple times. Variable bindings that are part of a lexical closure must not be unshared when this occurs. To avoid problems with unsharing that may occur when the stack is reified, assignment conversion converts assigned variables into explicit heap-allocated boxes, thereby avoiding problems with duplication of values. This conversion is best explained by showing it in Scheme source code:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">lambda</span> (x) ... x ... (set! x value) ...)
    <span class="kw">=&gt;</span>
(<span class="kw">lambda</span> (x)
    (<span class="kw">let</span> ((y (make-cell x)))
        ... (contents y) ... (set-contents! y value) ...))</code></pre></div>
<p>where <code>(make-cell x)</code> returns a new <code>cell</code> containing the value <code>x</code>, <code>(contents cell)</code> returns the value in <code>cell</code>, and <code>(set-contents! cell val)</code> updates <code>cell</code> with the new value <code>val</code>. After assignment conversion, the values of variables can no longer be altered - all side-effects are to data structures. This greatly simplifies the code transformation, because values may now be freely substituted for variables without having to first check to see whether they are assigned <span class="citation">[<a href="#ref-adams1986orbit">22</a>]</span>.</p></li>
<li><p>ANF Conversion - The code is converted to <em>administrative normal form</em> (A-normal form or ANF). Converting the code into A-normal form <span class="citation">[<a href="#ref-Flanagan1993">34</a>]</span> gives names to the temporary values and linearizes the control flow by replacing compound expressions with an equivalent sequence of primitive expressions and variable bindings. After ANF conversion, all procedure calls will either be the right-hand side of an assignment statement or a return statement. For instance, the following Scheme code shows the ANF transformation of a very simple expression:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(f (g x) (h y))
    <span class="kw">=&gt;</span>
(<span class="kw">let</span> ((v0 (g x)))
    (<span class="kw">let</span> ((v1 (h y)))
        (f v0 v1)))</code></pre></div>
<p>The following snippet shows the transformation for a fibonacci function in Java, considering as primitive subexpressions that can be evaluated without a method call:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">int</span> <span class="fu">fib</span> (<span class="dt">int</span> x) {
    <span class="kw">if</span> (x &lt; <span class="dv">2</span>)
        <span class="kw">return</span> x;
    <span class="kw">else</span>
        <span class="kw">return</span> <span class="fu">fib</span> (x - <span class="dv">2</span>) + <span class="fu">fib</span> (x - <span class="dv">1</span>);
}
    =&gt;
<span class="dt">int</span> <span class="fu">fib_an</span> (<span class="dt">int</span> x) {
    <span class="kw">if</span> (x &lt; <span class="dv">2</span>)
        <span class="kw">return</span> x;
    <span class="kw">else</span> {
        <span class="dt">int</span> temp0 = <span class="fu">fib_an</span> (x - <span class="dv">2</span>);
        <span class="dt">int</span> temp1 = <span class="fu">fib_an</span> (x - <span class="dv">1</span>);
        <span class="kw">return</span> temp0 + temp1;
    }
}</code></pre></div></li>
<li><p>Live variable analysis - We need to identify what variables are live at each continuation, i.e. at each fragment call. We are only interested in those variables that are live after a procedure or method call returns. For instance, in the previous code snippet, just before the last statement, <code>temp0</code> and <code>temp1</code> are alive, because they are used to compute the result to be returned. Conversely, <code>x</code> is no more live (is dead) as it is not used in the last statement. Unused or dead variables are not copied when the continuation is captured.</p></li>
<li><p>Procedure Fragmentation - For each actual procedure, we create a number of procedures each of which has the effect of continuing in the middle of the original procedure. This allows to restart execution right after each call site. Each procedure fragment will make a tail-recursive call to the next fragment. Fragmentation also replaces iteration constructs with procedure calls.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">int</span> <span class="fu">fib_an</span> (<span class="dt">int</span> x) {
    <span class="kw">if</span> (x &lt; <span class="dv">2</span>)
        <span class="kw">return</span> x;
    <span class="kw">else</span> {
        <span class="dt">int</span> temp0 = <span class="fu">fib_an</span> (x - <span class="dv">2</span>);
        <span class="kw">return</span> <span class="fu">fib_an0</span> (temp0, x);
    }
}

<span class="dt">int</span> <span class="fu">fib_an0</span> (<span class="dt">int</span> temp0, <span class="dt">int</span> x) {
    <span class="dt">int</span> temp1 = <span class="fu">fib_an</span> (x - <span class="dv">1</span>);
    <span class="kw">return</span> <span class="fu">fib_an1</span> (temp1, temp0);
}

<span class="dt">int</span> <span class="fu">fib_an1</span> (<span class="dt">int</span> temp1, <span class="dt">int</span> temp0) {
    <span class="kw">return</span> temp0 + temp1;
}</code></pre></div></li>
<li><p>Closure conversion - A continuation is composed of a series of frames, that are closed over the live variables in the original procedure. Each frame also has a method that accepts a single value (the argument to the continuation) and invokes the appropriate procedure fragment. These closures can be automatically generated if the underlying language were to support anonymous methods.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">abstract</span> <span class="kw">class</span> Frame {

    <span class="kw">abstract</span> Object <span class="fu">invoke</span>(Object arg)
        <span class="kw">throws</span> Throwable;
}

<span class="kw">class</span> fib_frame0 <span class="kw">extends</span> Frame {

    <span class="dt">int</span> x;

    <span class="fu">fib_frame0</span>(<span class="dt">int</span> x) {
        <span class="kw">this</span>.<span class="fu">x</span> = x;
    }

    <span class="fu">@Override</span>
    Object <span class="fu">invoke</span>(Object return_value)
        <span class="kw">throws</span> ContinuationException, Throwable {
        <span class="kw">return</span> <span class="fu">fib_an0</span>(x);
    }

}</code></pre></div></li>
<li><p>Code annotation - The fragmented code is annotated so that it can save its state in the appropriate continuation frame. Each procedure call is surrounded by an exception handler. This intercepts the special exception thrown for reifying the stack, constructs the closure object from the live variables, appends it to the list of frames contained by the special exception, and re-throws the exception. The calls in tail position are not annotated.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">int</span> <span class="fu">fib_an</span> (<span class="dt">int</span> x) {
    <span class="kw">if</span> (x &lt; <span class="dv">2</span>)
        <span class="kw">return</span> x;
    <span class="kw">else</span> {
        <span class="dt">int</span> temp0;
        <span class="kw">try</span> {
            temp0 = <span class="fu">fib_an</span> (x - <span class="dv">2</span>);
        } <span class="kw">catch</span> (ContinuationException sce) {
            sce.<span class="fu">extend</span> (<span class="kw">new</span> <span class="fu">fib_frame0</span> (x));
            <span class="kw">throw</span> sce;
        }
        <span class="kw">return</span> <span class="fu">fib_an0</span> (temp0, x);
    }
}

<span class="dt">int</span> <span class="fu">fib_an0</span> (<span class="dt">int</span> temp0, <span class="dt">int</span> x) {
    <span class="dt">int</span> temp1;
    <span class="kw">try</span> {
        temp1 = <span class="fu">fib_an</span> (x - <span class="dv">1</span>);
    } <span class="kw">catch</span> (ContinuationException sce) {
        sce.<span class="fu">extend</span> (<span class="kw">new</span> <span class="fu">fib_frame1</span> (temp0));
        <span class="kw">throw</span> sce;
    }
    <span class="kw">return</span> <span class="fu">fib_an1</span> (temp1, temp0);
}

<span class="dt">int</span> <span class="fu">fib_an1</span> (<span class="dt">int</span> temp1, <span class="dt">int</span> temp0) {
    <span class="kw">return</span> temp0 + temp1;
}</code></pre></div></li>
</ol>
<h3 id="java-frameworks-implementing-continuations">Java frameworks implementing continuations</h3>
<h4 id="kilim">Kilim</h4>
<p>The Kilim framework <span class="citation">[<a href="#ref-Srinivasan2006">30</a>, <a href="#ref-Bolton2000">31</a>]</span> provides lightweight actors, a type system that guarantees memory isolation between threads and a library with I/O support and synchronisation constructs and schedulers. It uses a restricted form of continuations that always transfers control to its caller but maintain an independent stack. Kilim implements a variant of generalized stack inspection <span class="citation">[<a href="#ref-Pettyjohn2005">25</a>]</span>. It transforms compiled programs at the bytecode-level, inserting copy and restore instructions to save the stack contents into a separate data structure (called a <em>fiber</em>) when a continuation is to be accessed. Its implementation is based on threee main architectural choices:</p>
<h5 id="suspend-resume">Suspend-Resume</h5>
<p>Kilim preserves the standard call stack, but provides a way to pause (suspend) the current stack and to store it in a continuation object called fiber. The fiber is resumed at some future time. Calling <code>Fiber.pause()</code> pops activation frames until it reaches the method that initiated <code>resume()</code>. This pair of calls is similar to the <code>shift</code> and <code>reset</code> operator from the literature on delimited continuations; they delimit the section of the stack to be saved.</p>
<h5 id="schedulable-continuations">Schedulable Continuations</h5>
<p>Kilim actors are essentially thread-safe wrappers around Fibers. A scheduler chooses which Actor to resume on which kernel thread. Kernel threads are treated as virtual processors while actors are viewed as agents that can migrate between kernel threads.</p>
<h5 id="generators">Generators</h5>
<p>Generators are essentially iterators that returns a stream of values. Each time we call a generator it gives us the next element. Kilim Generators are intended to be used by a single actor at a time, and run on the thread-stack of that actor. Even if the actor is running, it is prevented from executing any of its code until the generator yields the next element.</p>
<h4 id="javaflow">JavaFlow</h4>
<p>The Apache Commons JavaFlow <span class="citation">[<a href="#ref-Javaflow2015">35</a>]</span> is a library providing a continuations API for Java, accomplished via bytecode instrumentation which modifies the ordinary control flow of method calls to accomodate the ability to suspend and resume code execution at arbitrary points. JavaFlow transforms a method if it can reach a suspend() invocation. It transforms all non-pausable methods reachable from there as well, that are modified such that they can distinguish between normal execution, continuation capturing, and continuation resuming. This leads to inefficiencies, even when no continuations are used <span class="citation">[<a href="#ref-Stadler2009">36</a>]</span>. The instrumentation can be performed in advance or by a special class loader, which adds complexity either to the build process or to the application itself <span class="citation">[<a href="#ref-Srinivasan2006">30</a>, <a href="#ref-Bolton2000">31</a>]</span>.</p>
<h4 id="rife">RIFE</h4>
<p>RIFE <span class="citation">[<a href="#ref-RIFE2015">37</a>]</span> is Java web application framework which allows web applications to benefit from first-class continuations. RIFE's pure Java continuation engine, which uses Java bytecode manipulation to implement continuations, has been extracted into a standalone Java library. It works similar to the Javaflow library, but it allows continuation capturing only within a specific method (<code>processElement</code>), so that there is always only one activation frame per continuation <span class="citation">[<a href="#ref-Stadler2009">36</a>]</span>.</p>
<h4 id="picothreads">PicoThreads</h4>
<p>A PicoThread is a lightweight, user-level Java thread that can be cooperatively-scheduled, dispatched and suspended <span class="citation">[<a href="#ref-begel2000picothreads">38</a>]</span>. PicoThreads are implemented in the Java bytecode language via a Java class-to-class translation. The translation produces threaded programs that yield control and a continuation sufficient to restart the thread where it left off. A PicoThread continuation is a Java object which contains a reference to the object and method in which it was created. Since Java’s procedure call stacks do not have dynamic extent, PicoThread continuations also contain extra state to store a method’s local variables. PicoThread continuations extend Java exceptions, so that they can take advantage of Java’s zero-cost exception mechanism to pass continuations from method to method. However the authors PicoThreads were unable to find a Java implementation fast enough to use the library effectively.</p>
<h4 id="matthias-manns-continuations-library">Matthias Mann’s continuations library</h4>
<p>Matthias Mann’s continuations library implements continuations in Java using the ASM bytecode manipulation and analysis framework. The library provides an API allows to write coroutines and iterators in a sequential way <span class="citation">[<a href="#ref-ContinuationsLib2015">39</a>]</span>.</p>
<h3 id="kawas-continuations">Kawa's continuations</h3>
<p>Kawa provides a restricted type of continuations, that are implemented using Java exceptions, and can be used for early exit, but not to implement coroutines or generators <span class="citation">[<a href="#ref-Bothner1998">40</a>]</span>. The following code, though different from the actual implementation, explains the concept:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="kw">class</span> callcc <span class="kw">extends</span> Procedure1 {
        ...;
        <span class="kw">public</span> Object <span class="fu">apply1</span>(CallContext ctx) {
            Procedure proc = (Procedure) ctx.<span class="fu">value1</span>;
            Continuation cont
                = <span class="kw">new</span> <span class="fu">Continuation</span> (ctx);
            <span class="kw">try</span> {
                <span class="kw">return</span> proc.<span class="fu">apply1</span>(ctx);
                cont.<span class="fu">invoked</span> = <span class="kw">true</span>;
            } <span class="kw">catch</span> (CalledContinuation ex) {
                <span class="kw">if</span> (ex.<span class="fu">continuation</span> != cont)
                    <span class="kw">throw</span> ex;  <span class="co">// Re-throw.</span>
                <span class="kw">return</span> ex.<span class="fu">value</span>;
            }
        }
    }</code></pre></div>
<p>The <code>Procedure</code> that implements <code>call-with-current-continuation</code> creates a continuation object <code>cont</code>, that represents the current continuation, and passes it to the incoming Procedure <code>proc</code>. If <code>callcc</code> catches a <code>CalledContinuation</code> exception it means that <code>proc</code> invoked some <code>Continuation</code>. If it is the continuation of the current <code>callcc</code> instance, the code returns the value passed to the continuation; otherwise it re-throws the exception until a matching handler is reached.</p>
<p>The continuation is marked as <code>invoked</code>, to detect unsupported invocation of cont after <code>callcc</code> returns. (A complete implementation of continuations would instead copy the stack to the heap, so it can be accessed at a later time.)</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="kw">class</span> Continuation <span class="kw">extends</span> Procedure1 {
        ...;
        <span class="kw">public</span> Object <span class="fu">apply1</span>(CallContext ctx) {
            <span class="kw">if</span> (invoked)
                <span class="kw">throw</span> <span class="kw">new</span> GenericError
                    (<span class="st">&quot;Continuation can only be used once&quot;</span>);
            <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">CalledContinuation</span> (ctx.<span class="fu">values</span>, <span class="kw">this</span>, ctx);
        }
    }</code></pre></div>
<p>A <code>Continuation</code> is the actual continuation object that is passed to <code>callcc</code>; when it is invoked, it throws a <code>CalledContinuation</code> that contains the continuation and the value returned.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="kw">class</span> CalledContinuation
        <span class="kw">extends</span> RuntimeException {
        ...;
        Object value;
        Continuation continuation;
        CallContext ctx;
        <span class="kw">public</span> CalledContinuation
            (Object value, Continuation cont, CallContext ctx) {
            <span class="kw">this</span>.<span class="fu">value</span> = value;
            <span class="kw">this</span>.<span class="fu">continuation</span> = cont;
            <span class="kw">this</span>.<span class="fu">ctx</span> = ctx;
        }
    }</code></pre></div>
<h1 id="implementing-first-class-continuations-on-the-jvm">Implementing first-class continuations on the JVM</h1>
<blockquote>
<em>&quot;I don't care what anything was designed to do. I care about what it can do.&quot;</em>
<p class="citright">
Apollo 13 (film, 1995)
</p>
</blockquote>
<h2 id="the-stack-manipulation-dilemma">The stack manipulation dilemma</h2>
<p>The use of virtual machines for the implementation of programming languages has become common in recent compiler developments. Unlike low-level languages, such as C, that permit access to the stack through use of pointer arithmetic, higher level languages, such as Java or C# do not provide instructions for installing and saving the run-time stack. Compiling Scheme, or any other language that uses first-class continuations, to the JVM thus poses a challenging problem. At first glance, the implementers must either give up implementing continuations or manage a heap-stored stack. The former choice limits the programmers of these languages, besides automatically making the Scheme implementation non standard-compliant. The latter choice precludes many of the advantages that these machines supposedly offer. Indeed, the major problem with heap allocation of call frames and environments is the overhead associated with the use of a heap. This overhead includes the direct cost of allocating objects in the heap when building the call frames and environments, and of following references instead of increasing and decreasing a stack or frame pointer when accessing pieces of the frame or environment. The overhead also includes the indirect cost of garbage collection to manage stack frames and environments and the indirect cost of using significant amounts of memory. Furthermore, the use of the heap rather than a stack prevents the exploitation of commonly available hardware or microcode-supported stack push, pop and index instructions and the use of function call and return instructions.</p>
<h2 id="a-solution-generalises-stack-inspection">A solution: generalises stack inspection</h2>
<p>The idea is to fragment the original program in a sequence of atomic computations, then to throw an exception to unwind the stack, and use the same exception to store the list of computations that constitute the stack portion to be captured. This list of computations can be later used to restate the entire continuation. As an example, consider the stack of nested function calls in Figure . At top level we call <code>topLevel</code>, that in turn calls <code>f</code>, which calls <code>g</code>, which call <code>call/cc</code> with <code>h</code> as argument. <code>h</code> is a function that takes one argument. Each call is enclosed in an exception handler that catches a <code>ContinuationException</code>.</p>
<div class="figure">
<img src="figures/stack.png" alt="" />
<p class="caption"></p>
</div>
<p>When the <code>call/cc</code> is called, it creates a new <code>ContinuationException</code> object, adds the computation associated to <code>h</code> to the list, and throws the exception. Just after the <code>throw</code>, the execution stops and the JVM searches routines in the stack for an exception handler. The first <code>try</code>/<code>catch</code> expression found, that is in <code>g</code>, extends the list with an other computation and re-throws the exception.</p>
<div class="figure">
<img src="figures/stack_mod.png" alt="" />
<p class="caption"></p>
</div>
<p>The exception goes past the try block to try blocks in an outer scope. At each step a new computation is added to the <code>ContinuationException</code>, until the control goes to the top level exception handler, which assembles the actual exception object. Searching in outer scopes for exception handlers is called a <em>stack walk</em>. While the stack unwinds, the JVM pops the stack frames off of the stack, destroying all the stack allocated variables. However, as all the computation steps are saved in the <code>ContinuationException</code>, a copy of the stack is progressively created on the heap. The exception always maintains a reference to the list of computations during the stack walk, so that the continuation is not garbage-collected.</p>
<p>The top level handler, besides assembling the continuation object, resumes the execution of <code>h</code>, the function passed to the <code>call/cc</code>, passing to it the continuation as argument. If <code>h</code> does not invoke the continuation, the top level handler resumes the continuation after <code>h</code> returns. Figure  illustrates the process.</p>
<div class="figure">
<img src="figures/frames.png" alt="Stack and heap during a continuation capture " />
<p class="caption">Stack and heap during a continuation capture </p>
</div>
<p>Figure  shows what happens in the stack and in the heap when a continuation is captured by <code>call/cc</code>. When <code>call/cc</code> is called the stack frames belonging to the continuation are under the <code>call/cc</code>'s one (assuming the stack growing bottom-up). Throwing the <code>ContinuationException</code>, <code>call/cc</code> starts to unwind the stack, and consequently the heap starts to be populated by the continuation frames. When top level is reached, the handler creates the continuation object. At the end of the process, the <code>h</code> function is resumed with the continuation object bound to its single argument.</p>
<div class="figure">
<img src="figures/frames-call.png" alt="Stack and heap when reinstating a continuation " />
<p class="caption">Stack and heap when reinstating a continuation </p>
</div>
<p>An interesting property of first-class continuations is that they can be invoked at any time, provided that they are saved in an accessible variable. When a continuation is invoked, it throws an <code>ExitException</code>. This causes the stack to be unwind, as in the capture case. The top level handler in this case resumes the continuation frames stored in the continuation object. The final result is that the execution restart where it was suspended by the call/cc, while the heap continues to store the continuation object. This can be accessed other times, or can be garbage-collected if it is no more used.</p>
<h2 id="generalised-stack-inspection-for-a-jvm-based-scheme">Generalised stack inspection for a JVM-based Scheme</h2>
<p>This section shows how the generalised stack inspection technique described by Pettyjohn et al. can be adapted to be used on the JVM, and how it can be included in a Scheme compiler. We will see also how some issues leaved open by the original paper have been tackled.</p>
<h3 id="assignment-conversion">Assignment conversion</h3>
<p>In our case, this step is not necessary. Indeed, management of shared variable bindings is an orthogonal issue with respect to our global transformation, and it is shared between all the languages that provide lexical closures. Kawa already supports lexical closures, so has its way of managing variable bindings. For each closure, Kawa creates a new class to represent a function together with the environment of captured variables.</p>
<h3 id="a-normalization">A-Normalization</h3>
<p>The first step of the process is to transform the source to A-normal form. ANF was introduced by Flanagan et al. in <span class="citation">[<a href="#ref-Flanagan1993">34</a>]</span> as an intermediate representation for compilers. It encodes data flow explicitly by naming all sub-expressions within the program and permitting only a single definition of any particular variable. The paper by Flanagan et al. also presents a basic linear-time A-normalization algorithm for a subset of Scheme. The algorithm can be easily extended to handle top-level defines and side effects <span class="citation">[<a href="#ref-ANFMight2015">41</a>]</span>. Being Kawa a super-set of R7RS Scheme and having also many Java related extensions, the code of the original A-normalizer must be further extended. Instead of performing the transformation directly on the Scheme source, I opted for performing it on the abstract syntax tree, as it already uses a reduced set of expression types.</p>
<p>The following code shows an instance of the transformation in three steps. The <em>return</em> operation corresponds to the identity function, while the <em>bind</em> operation is a function that constructs let bindings to make every atomic computation explicit (the bind here has the same purpose as the <code>normalizeName</code> function in the Flanagan et al. paper).</p>
<p>The syntax tree is traversed starting from the root, and each non-atomic expression is passed to the <code>bind</code> with another parameter, called <em>context</em> (the very first context is the identity function that returns its argument). The context is a function that can be invoked. When the visiting process reaches a non-atomic expression a new context is created, and the passed context is called only inside the new one. The <code>bind</code> function has two purposes:</p>
<ol style="list-style-type: decimal">
<li>to create a context, that generates a <code>let</code> expression to let-bind the expression next to come in the traversing process;</li>
<li>to visit the passed expression, to continue the syntax tree traversing.</li>
</ol>
<p>This chain finish when a leaf (an atomic expression) is encountered in the tree, in this case the passed context is invoked (which in turn will invoke the previous context and so on). At this point the chain of context invocations starts to wrap each expression in a <code>let</code> binding, processing the expressions backward, and enclosing them step by step in nested <code>let</code> expressions. This backward traversing stops when the context called is the identity function. This happens in the leaves.</p>
<p>When the expression to normalize is a conditional, the <code>bind</code> is used on each branch expression. Instead of creating a let binding for each branch, as they cannot be evaluated before the test outcome, <code>bind</code> calls the visit method with the identity context, restarting the normalization in each branch.</p>
<p>The following code shows the a-normalization process for a simple Scheme expression. Note that the internal <code>if</code> expression should be further normalized, but we consider it atomic here, to keep the example short. The algoritm performs a monadic transformation combining three steps:</p>
<ol style="list-style-type: decimal">
<li>Monadic conversion:</li>
</ol>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">   (<span class="kw">+</span> <span class="dv">1</span>                             (bind (<span class="kw">if</span> (<span class="kw">&gt;=</span> x <span class="dv">0</span>)
      (<span class="kw">if</span> (<span class="kw">&gt;=</span> x <span class="dv">0</span>)                            (f x)
          (f x)             --&gt;               (return <span class="dv">0</span>))
          <span class="dv">0</span>))                             (<span class="kw">lambda</span> (t) (<span class="kw">+</span> <span class="dv">1</span> t)))</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>The result is interpreted in the identity monad:</li>
</ol>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">                (return a)  <span class="kw">=&gt;</span>  a

   (bind a (<span class="kw">lambda</span> (x) b))  <span class="kw">=&gt;</span>  (<span class="kw">let</span> ((x a)) b)


   (bind (<span class="kw">if</span> (<span class="kw">&gt;=</span> x <span class="dv">0</span>)               (<span class="kw">let</span> ((t (<span class="kw">if</span> (<span class="kw">&gt;=</span> x <span class="dv">0</span>)
             (f x)          --&gt;                  (f x)
             (return <span class="dv">0</span>))                         (return <span class="dv">0</span>))))
          (<span class="kw">lambda</span> (t) (<span class="kw">+</span> <span class="dv">1</span> t)))        (<span class="kw">+</span> <span class="dv">1</span> t))</code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li>Nested let are flattened:</li>
</ol>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">   (<span class="kw">let</span> ((x (<span class="kw">let</span> ((y a))               (<span class="kw">let</span> ((y a))
              b)))          --&gt;          (<span class="kw">let</span> ((x b))
     c)                                    c))</code></pre></div>
<h3 id="code-fragmentation">Code fragmentation</h3>
<p>This transformation, working on code previously A-normalized, fragments the code in a sequence of function calls. Each let-bind expression is enclosed in a lambda closure that accepts one argument. The argument is an other lambda closure that has in the body the call to the next code fragment. In this way the original source is rewritten as a sequence of function calls, each call representing a computation step. This way of fragmenting the source allows to avoid defining many top level procedures, that would also require an additional pass to perform live variable analysis.</p>
<p>An example of the entire transformation is showed below:</p>
<ol style="list-style-type: decimal">
<li>original source</li>
</ol>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">define</span><span class="fu"> incr </span><span class="dv">#f</span>)

    (<span class="kw">+</span> (<span class="kw">call/cc</span>
          (<span class="kw">lambda</span> (k)
              (set! incr k)
              <span class="dv">0</span>))
      <span class="dv">1</span>) <span class="co">; =&gt; 1</span></code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>after A-normalization</li>
</ol>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">let</span> ((v1 (<span class="kw">lambda</span> (k)              <span class="co">; computation #1</span>
            (<span class="kw">let</span> ((v0 (set! incr k)))
              <span class="dv">0</span>))))
     (<span class="kw">let</span> ((v2 (<span class="kw">call/cc</span> v1)))          <span class="co">; computation #2</span>
       (<span class="kw">+</span> v2 <span class="dv">1</span>))))                     <span class="co">; computation #3</span></code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li>after fragmentation</li>
</ol>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    ((<span class="kw">lambda</span> (incr_an1)                <span class="co">; fragment #1</span>
      (<span class="kw">let</span> ((v1 (<span class="kw">lambda</span> (k)
                  (<span class="kw">let</span> ((v0 (set! incr k)))
                    <span class="dv">0</span>))))
         (incr_an1 v1)))
     (<span class="kw">lambda</span> (v1)
       ((<span class="kw">lambda</span> (incr_an2)             <span class="co">; fragment #2</span>
          (<span class="kw">let</span> ((v2 (<span class="kw">call/cc</span> v1)))
            (incr_an2 v2)))
        (<span class="kw">lambda</span> (v2)
          (<span class="kw">+</span> v2 <span class="dv">1</span>)))))                 <span class="co">; fragment #3</span></code></pre></div>
<h3 id="live-variable-analysis-and-closure-conversion">Live variable analysis and closure conversion</h3>
<p>Kawa's support for lexical closures allows to completely avoid these steps. Each fragment, created as described in the previous section, is closed over the values of the variables that are live at that point.</p>
<p>A continuation will be composed of a series of frames. A <em>frame</em> is an object with a method that accepts a single value (the argument to the continuation) and invokes the appropriate procedure fragment, to continue the computation from the capture point. Also these frames will be closed over the next fragment to call.</p>
<h3 id="code-instrumentation">Code Instrumentation</h3>
<p>Beside fragmentation, instrumentation is performed for installing exception handlers around each computation step to enable the capture and resume of continuations. Kawa supports <code>try-catch</code> expressions, which are translated directly to native <code>try/catch</code> statements in Java bytecode. A <code>try-catch</code> expression is created around each computation to capture a possible <code>ContinuationException</code>. The installed exception handler adds a new frame (an invokable object enclosing a call the next computation step) to the list of frames included inside the <code>ContinuationException</code> object, then rethrows the exception.</p>
<p>The following code resembles the final result after instrumentation:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    ((<span class="kw">lambda</span> (incr_an1)
      (<span class="kw">let</span> ((v1 (<span class="kw">lambda</span> (k)
                  (<span class="kw">let</span> ((v0 (set! incr k)))
                    <span class="dv">0</span>))))
         (incr_an1 v1)))
     (<span class="kw">lambda</span> (v1)
       ((<span class="kw">lambda</span> (incr_an2)
          (<span class="kw">let</span> ((v2 (try-catch (<span class="kw">call/cc</span> v1)             <span class="co">; try/catch</span>
                      (cex &lt;ContinuationException&gt;      <span class="co">; handler</span>
                         (<span class="kw">let</span> ((f (<span class="kw">lambda</span> (continue-value)
                                    (incr_an2 continue-value))))
                         (cex:extend (&lt;ContinuationFrame&gt; f))
                         (throw cex))))))               <span class="co">; re-throw</span>
            (incr_an2 v2)))
        (<span class="kw">lambda</span> (v2)
          (<span class="kw">+</span> v2 <span class="dv">1</span>)))))</code></pre></div>
<h2 id="issues">Issues</h2>
<h3 id="callcc-in-higher-order-functions"><code>call/cc</code> in higher order functions</h3>
<p>Since Kawa optimise some built-in procedures (like <code>map</code>, <code>foreach</code> and <code>filter</code>) implementing them as Java methods, and because of the global transformation needed by the <code>call/cc</code>, continuations cannot be captured inside functions passed to those higher order functions. Indeed, the Java implementation of map (<code>gnu.kawa.functions.Map</code>) is not 'aware' of continuations, thus when you use <code>call/cc</code> inside the lambda passed to <code>map</code>, it will not be able to handle a <code>ContinuationException</code>, resulting in a runtime error.</p>
<p>In the next chapter, we will see a possible solution to this problem.</p>
<h3 id="code-size">Code size</h3>
<p>The creation of fragments will introduce a number of extra code. Although the overhead should be small, there will be an increase in code size proportional to the number of code fragments.</p>
<p>Code instrumentation introduces a number of <code>try/catch</code> blocks. This will also increase code size proportional to the number of code fragments. Chapter 6 will present an estimate of the code size increase.</p>
<h3 id="integration">Integration</h3>
<p>Given that the code transformation needed to support continuations adds a overhead to the compilation process and the generated bytecode, it is necessary to implement A-normalization and instrumentation as optional passes, that can be enabled only when we want to use <code>call/cc</code>. This adds the challenge of integrating such a global transformation in Kawa, avoiding to make too many changes to the compiler.</p>
<h1 id="a-callcc-implementation-for-kawa">A call/cc implementation for Kawa</h1>
<blockquote>
<em>&quot;Do... or do not. There is no try.&quot;</em>
<p class="citright">
The Empire Strikes Back (film, 1980)
</p>
</blockquote>
<h2 id="an-instance-of-the-transformation-in-java">An instance of the transformation in Java</h2>
<p>As a first preliminary step, I ported the C# code in <span class="citation">[<a href="#ref-StackHack2005">32</a>]</span> to Java, to study the feasibility of the technique on the JVM. The code represents a single instance of the transformation for a simple fibonacci function, and implements some support functions and data structures. Given that the global transformation fragments the original source in many function calls, I produced four versions of the transformed code, to compare the performance of different type of calls on the JVM:</p>
<ol style="list-style-type: decimal">
<li>The first one uses nested static classes to implement the continuation frames of the function to be run:</li>
</ol>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="kw">class</span> fib_frame0 <span class="kw">extends</span> Frame {

        <span class="dt">int</span> x;

        <span class="kw">public</span> <span class="fu">fib_frame0</span>(<span class="dt">int</span> x) { <span class="kw">this</span>.<span class="fu">x</span> = x; }
        <span class="fu">@Override</span>
        <span class="kw">public</span> Object <span class="fu">invoke</span>(Object return_value)
                <span class="kw">throws</span> ContinuationException, Throwable {
            <span class="co">// call to the next fragment</span>
            <span class="kw">return</span> <span class="fu">fib_an0</span>(x);
        }
    }

    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">fib_an</span>(<span class="dt">int</span> x)
          <span class="kw">throws</span> ContinuationException, Throwable {
        <span class="kw">try</span> {
            <span class="fu">pause</span>();
        } <span class="kw">catch</span> (ContinuationException sce) {
            sce.<span class="fu">extend</span>(<span class="kw">new</span> <span class="fu">ContinuationFrame</span>(<span class="kw">new</span> <span class="fu">fib_frame0</span>(x)));
            <span class="kw">throw</span> sce;
        }

        <span class="kw">return</span> <span class="fu">fib_an0</span>(x);
    }</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>the second version uses <code>MethodHandle</code>s, that were introduced in Java 7. A <code>MethodHandle</code> is a typed, directly executable reference to an underlying method, constructor or field:</li>
</ol>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="dt">static</span> Object <span class="fu">fib_frame0_invoke</span>(Object x, Object continue_value)
            <span class="kw">throws</span> SaveContinuationException, Exception {
         <span class="kw">return</span> <span class="fu">fib_an0</span> ((<span class="dt">int</span>) x);
    }

    <span class="dt">static</span> MethodHandle <span class="fu">fib_frame0</span>(<span class="dt">int</span> x)
            <span class="kw">throws</span> Exception {
        MethodType mt = MethodType.<span class="fu">methodType</span>(Object.<span class="fu">class</span>,
                                              Object.<span class="fu">class</span>,
                                              Object.<span class="fu">class</span>);
        MethodHandle handle = lookup.<span class="fu">findStatic</span>(fib_mh.<span class="fu">class</span>,
                                                <span class="st">&quot;fib_frame0_invoke&quot;</span>,
                                                mt);

        <span class="kw">return</span> handle.<span class="fu">bindTo</span>(x);
    }

    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">fib_an</span>(<span class="dt">int</span> x)
           <span class="kw">throws</span> SaveContinuationException, Exception {
        <span class="kw">try</span> {
            <span class="fu">pause</span>();
        } <span class="kw">catch</span> (SaveContinuationException sce) {
            sce.<span class="fu">Extend</span>(<span class="kw">new</span> <span class="fu">ContinuationFrame</span>(<span class="fu">fib_frame0</span>(x)));
            <span class="kw">throw</span> sce;
        }

        <span class="kw">return</span> <span class="fu">fib_an0</span>(x);
    }</code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li>the third version uses Java 8 lambdas, specified with the new Java syntax:</li>
</ol>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="dt">static</span> Object <span class="fu">fib_frame0_invoke</span>(Object x, Object continue_value)
            <span class="kw">throws</span> SaveContinuationException, Exception {
         <span class="kw">return</span> <span class="fu">fib_an0</span> ((<span class="dt">int</span>) x);
    }

    <span class="dt">static</span> Frame <span class="fu">fib_frame0</span>(<span class="dt">int</span> x)
            <span class="kw">throws</span> Exception {
        Frame f = (Object continue_value)
                   -&gt; {
                        <span class="kw">return</span> <span class="fu">fib_frame0_invoke</span>(x, continue_value);
                      };
        <span class="kw">return</span> f;
    }

    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">fib_an</span>(<span class="dt">int</span> x)
            <span class="kw">throws</span> SaveContinuationException, Exception {
        <span class="kw">try</span> {
            <span class="fu">pause</span>();
        } <span class="kw">catch</span> (SaveContinuationException sce) {
            sce.<span class="fu">Extend</span>(<span class="kw">new</span> <span class="fu">ContinuationFrame</span>(<span class="fu">fib_frame0</span>(x)));
            <span class="kw">throw</span> sce;
        }

        <span class="kw">return</span> <span class="fu">fib_an0</span>(x);
    }</code></pre></div>
<ol start="4" style="list-style-type: decimal">
<li>the last version generates lambdas explicitly using LambdaMetafactory, an API introduced in Java 8 to facilitate the creation of simple function objects.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    fib_frame0_factory
        = LambdaMetafactory
            .<span class="fu">metafactory</span>(lookup,
                         <span class="st">&quot;invoke&quot;</span>,
                         invokedType,
                         methodType,
                         lookup.<span class="fu">findStatic</span>(fib_meta.<span class="fu">class</span>,
                                           <span class="st">&quot;fib_frame0_invoke&quot;</span>,
                                           implType),
                         methodType).<span class="fu">dynamicInvoker</span>();

    <span class="dt">static</span> Object <span class="fu">fib_frame0_invoke</span>(Object x, Object continue_value)
            <span class="kw">throws</span> SaveContinuationException, Throwable {
         <span class="kw">return</span> <span class="fu">fib_an0</span> ((<span class="dt">int</span>) x);
    }

    <span class="dt">static</span> Frame <span class="fu">fib_frame0</span>(<span class="dt">int</span> x)
            <span class="kw">throws</span> Throwable {
        <span class="kw">return</span> (Frame) fib_frame0_factory.<span class="fu">invoke</span>(x);
    }</code></pre></div>
<p>I tested each type of method call with JMH <span class="citation">[<a href="#ref-jmh2015">42</a>, <a href="#ref-BenchmarkingJVM2015">43</a>]</span>, a benchmarking framework for the JVM. Figures  ,  show the results. The lambda case is quite fast, if compared with MethodHandles, but also the explicit use of LambdaMetafactory gives good results, provided that the call to LambdaMetafactory.metafactory is cached in a static field. However, the difference in performance between lambda calls and regular method calls is negligible. Thus is not worth to re-design a significant part of the compiler, and to loose the compatibility with previous version of the JVM, for such a small improvement.</p>
<div class="figure">
<img src="figures/calls-table.png" alt="Performance comparison of different types of call in Java " />
<p class="caption">Performance comparison of different types of call in Java </p>
</div>
<div class="figure">
<img src="figures/calls.png" alt="Performance comparison of different types of call in Java " />
<p class="caption">Performance comparison of different types of call in Java </p>
</div>
<h3 id="exceptions-performance-in-java">Exceptions performance in Java</h3>
<p>The capture of a continuation, and in particular the stack copying mechanism, is driven by exception throwing and exception handling. Therefore, is crucial to understand how the installation of exception handlers and the construction of an Exception object impact the performance.</p>
<p>In Java, when throwing an exception, the most expensive operation is the construction of the stack trace, that is useful for debugging reasons. As well as we are not using exceptions with they original purpose, we can have rid of the stack trace construction and optimise the <code>Exception</code> object. It is sufficient to override the <code>fillInStackTrace</code> method of <code>Throwable</code>:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> FastException <span class="kw">extends</span> Exception {

        <span class="fu">@Override</span>
        <span class="kw">public</span> Throwable <span class="fu">fillInStackTrace</span>() {
            <span class="kw">return</span> <span class="kw">this</span>;
        }
    }</code></pre></div>
<p>I performed a straightforward benchmark, comparing the time spent by a regular method call, a method call surrounded by an exception handler, a method call throwing a caught exception and a method call throwing a <code>FastException</code>.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">        <span class="co">// case 1</span>
        t.<span class="fu">method1</span>(i);

        <span class="co">// case 2</span>
        <span class="kw">try</span> {
            t.<span class="fu">method2</span>(i);
        } <span class="kw">catch</span> (Exception e) {
            <span class="co">// We will *never* get here</span>
        }

        <span class="co">// case 3</span>
        <span class="kw">try</span> {
            t.<span class="fu">method3</span>(i);
        } <span class="kw">catch</span> (Exception e) {
            <span class="co">// We will get here</span>
        }

        <span class="co">// case 4</span>
        <span class="kw">try</span> {
            t.<span class="fu">method4</span>(i);
        } <span class="kw">catch</span> (FastException e) {
            <span class="co">// We will get here</span>
        }</code></pre></div>
<p>The results from 10 million iterations are shown in the following table.</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">time (ms)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">regular</td>
<td align="left">1225</td>
</tr>
<tr class="even">
<td align="left">no caught exception</td>
<td align="left">1240</td>
</tr>
<tr class="odd">
<td align="left">caught exception</td>
<td align="left">35482</td>
</tr>
<tr class="even">
<td align="left">caught, optimised</td>
<td align="left">1330</td>
</tr>
</tbody>
</table>
<p>As you can see, to catch a <code>FastException</code> introduces a negligible overhead, while instantiating an <code>Exception</code> with its stack trace is more than an order of magnitude more expensive.</p>
<h2 id="support-code">Support code</h2>
<p>For capturing and resuming continuations we need a framework to support all the required operations, such as construct an object that models the continuation, and turn a continuation object back into an actual continuation.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> ContinuationFrame {

        Procedure computation;
        ArrayList&lt;ContinuationFrame&gt; continuation;

        <span class="kw">public</span> <span class="fu">ContinuationFrame</span>(Procedure frame) {
            computation = frame;
        }
    }</code></pre></div>
<p>The basic blocks of a continuation are its <code>ContinuationFrame</code>s. A <code>ContinuationFr-</code> <code>ame</code> (for brevity, a frame) is a simple data structure which contains a single computation (a <code>Procedure</code> that takes one argument), and a list of <code>ContinuationFrame</code>s. The list is used by the next capture of a continuation. All the frames needed to assemble a continuation are collected using a <code>ContinuationException</code>. This class extends <code>FastException</code> and stores the list of frames which is extended step by step by the chain of throws. It contains also a list of frames that have been already reloaded by a previously call to <code>call/cc</code>. When the exception reaches the top level exception handler, this calls the method <code>toContinuation</code> that builds a new <code>Continuation</code> object using the two lists.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> ContinuationException <span class="kw">extends</span> FastException {

    ArrayList&lt;ContinuationFrame&gt;
    newCapturedFrames = <span class="kw">new</span> ArrayList&lt;ContinuationFrame&gt;();

    ArrayList&lt;ContinuationFrame&gt; reloadedFrames;

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">extend</span>(ContinuationFrame extension) {
        newCapturedFrames.<span class="fu">add</span>(extension);
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">append</span>(ArrayList&lt;ContinuationFrame&gt; oldFrames) {
        reloadedFrames = oldFrames;
    }

    <span class="kw">public</span> Continuation <span class="fu">toContinuation</span>() <span class="kw">throws</span> Exception {
        <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Continuation</span>(newCapturedFrames,
                                reloadedFrames);
    }
}</code></pre></div>
<p>The <code>Continuation</code> constructor takes the two lists and assembles the continuation.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> Continuation <span class="kw">extends</span> Procedure0or1 {

    ArrayList&lt;ContinuationFrame&gt; frames;

    <span class="kw">public</span> <span class="fu">Continuation</span>(ArrayList&lt;ContinuationFrame&gt; newFrames,
                        ArrayList&lt;ContinuationFrame&gt; oldFrames) {

        frames = (oldFrames != <span class="kw">null</span>)
                 ? <span class="kw">new</span> ArrayList&lt;ContinuationFrame&gt;(oldFrames)
                 : <span class="kw">new</span> ArrayList&lt;ContinuationFrame&gt;();

        <span class="kw">for</span>(<span class="dt">int</span> i = newFrames.<span class="fu">size</span>()-<span class="dv">1</span>; i &gt;= <span class="dv">0</span>; i--) {
            ContinuationFrame newFrame = newFrames.<span class="fu">get</span>(i);
            <span class="kw">if</span> (newFrame.<span class="fu">continuation</span> != <span class="kw">null</span>) {
               <span class="kw">throw</span> <span class="kw">new</span> Error(<span class="st">&quot;Continuation should be empty here&quot;</span>);
            }
            newFrame.<span class="fu">continuation</span>
               = <span class="kw">new</span> ArrayList&lt;ContinuationFrame&gt;(frames);
            frames.<span class="fu">add</span>(newFrame);
        }
    }</code></pre></div>
<p>When a continuation is invoked, we actually call the <code>apply</code> method of <code>Continuation</code>. Here we create a new procedure which, when called, resumes the continuation. We wrap the procedure in an exception so that, throwing it, we unload the <em>current</em> continuation. The top level handler will receive this exception and will use it to resume the <em>invoked</em> continuation.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="kw">public</span> Object <span class="fu">apply0</span>() <span class="kw">throws</span> Throwable {
        <span class="kw">return</span> <span class="fu">apply1</span>(Values.<span class="fu">empty</span>);
    }

    <span class="kw">public</span> Object <span class="fu">apply1</span>(<span class="dt">final</span> Object val) <span class="kw">throws</span> Throwable {

        Procedure t = <span class="kw">new</span> <span class="fu">Procedure1</span>() {

            <span class="kw">public</span> Object <span class="fu">apply1</span>(Object ignored) <span class="kw">throws</span> Throwable {
                <span class="kw">return</span> <span class="fu">reloadFrames</span>(frames.<span class="fu">size</span>()-<span class="dv">2</span>, val);
            }
        };

        <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">ExitException</span>(t);
    }</code></pre></div>
<p>The <code>Continuation</code> object also contains the method to resume the continuation. <code>reloadFrames</code> iterates over the list of frames in reverse order to re-establish the saved continuation reconstructing the stack. The topmost frame gets the restart value passed into it.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    Object <span class="fu">resume</span>(<span class="dt">final</span> Object restartValue) <span class="kw">throws</span> Throwable {
        <span class="kw">return</span> <span class="fu">reloadFrames</span>(frames.<span class="fu">size</span>()-<span class="dv">1</span>, restartValue);
    }

    Object <span class="fu">reloadFrames</span>(<span class="dt">int</span> endIndex, Object restartValue)
    <span class="kw">throws</span> Throwable {
        Object continueValue = restartValue;
        <span class="kw">for</span> (<span class="dt">int</span> i = endIndex; i &gt;= <span class="dv">0</span>; i -= <span class="dv">1</span>) {
            ContinuationFrame frame = frames.<span class="fu">get</span>(i);
            <span class="kw">try</span> {
                continueValue = frame.<span class="fu">computation</span>
                                        .<span class="fu">apply1</span>(continueValue);
            } <span class="kw">catch</span> (ContinuationException sce) {
                sce.<span class="fu">append</span>(frame.<span class="fu">continuation</span>);
                <span class="kw">throw</span> sce;
            }
        }
        <span class="kw">return</span> continueValue;
    }

}</code></pre></div>
<p><code>TopLevelHandler</code> deals with running top level calls in an exception handler that catches instances of <code>ContinuationException</code>, thrown by <code>call/cc</code>, and <code>ExitException</code>, thrown by a continuation invocation. In the first case it creates a continuation object and resumes the execution of the function passed to <code>call/cc</code>. In the second case it calls the function enclosed in the <code>ExitException</code>, which reinstates the continuation.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> TopLevelHandler <span class="kw">extends</span> Procedure1 {

    <span class="kw">public</span> Object <span class="fu">apply1</span>(Object arg1) <span class="kw">throws</span> Throwable {
        <span class="kw">return</span> <span class="fu">runInTopLevelHandler</span>((Procedure) arg1);
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">compile</span>(...) { <span class="kw">... </span>}

    <span class="kw">public</span> <span class="dt">static</span> Object <span class="fu">runInTopLevelHandler</span>(Procedure initialFrame)
    <span class="kw">throws</span> Throwable {
        <span class="kw">while</span> (<span class="kw">true</span>) {
            <span class="kw">try</span> {
                <span class="kw">return</span> <span class="fu">invokeFrame</span>(initialFrame);
            } <span class="kw">catch</span> (ExitException rce) {
                initialFrame = rce.<span class="fu">thunk</span>;
            }
        }
    }

    <span class="kw">private</span> <span class="dt">static</span> Object <span class="fu">invokeFrame</span>(<span class="dt">final</span> Procedure initialFrame)
    <span class="kw">throws</span> Throwable {
        <span class="kw">try</span> {
            <span class="kw">return</span> initialFrame.<span class="fu">apply1</span>(<span class="kw">null</span>);
        } <span class="kw">catch</span> (ContinuationException sce) {
            <span class="dt">final</span> Continuation k = sce.<span class="fu">toContinuation</span>();

            Procedure f = <span class="kw">new</span> <span class="fu">Procedure1</span>() {

                <span class="kw">public</span> Object <span class="fu">apply1</span>(Object arg) <span class="kw">throws</span> Throwable {
                    <span class="kw">return</span> k.<span class="fu">resume</span>(k);
                }
            };

            <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">ExitException</span>(f);
        }
    }
}</code></pre></div>
<p>The <code>CallCC</code> procedure implements <code>call/cc</code>. It throws a new <code>ContinuationException</code>, saving in it the <code>call/cc</code> argument (a <code>Procedure</code> object).</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> CallCC <span class="kw">extends</span> Procedure1 {

    <span class="kw">public</span> Object <span class="fu">apply1</span>(Object arg1) <span class="kw">throws</span> Throwable {
        <span class="kw">return</span> <span class="fu">call_cc</span>((Procedure) arg1);
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">compile</span>(...) { <span class="kw">... </span>}

    <span class="kw">public</span> <span class="dt">static</span> Object <span class="fu">call_cc</span>(<span class="dt">final</span> Procedure receiver)
    <span class="kw">throws</span> ContinuationException {
        <span class="kw">try</span> {
            <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">ContinuationException</span>();
        } <span class="kw">catch</span> (ContinuationException sce) {
            sce.<span class="fu">extend</span>(<span class="kw">new</span> <span class="fu">ContinuationFrame</span>(receiver));
            <span class="kw">throw</span> sce;
        }
    }
}</code></pre></div>
<p>A significant variation with respect to the implementation proposed by Pettyjohn et al. is that the function that resumes the stack frames is implemented using iteration instead of recursion. This avoids using too much stack, as the JVM, differently from the C# MSIL, does not support tail call optimisation. Another difference is in the representation of the list of frames. Instead of using a linked list adding elements at the beginning, I used a Java <code>ArrayList</code>, adding elements at the end of the list. This allows to avoid reversing a list at every capture, and saves an object allocation at each list extension.</p>

<h2 id="a-brief-overview-of-kawas-compilation-process">A brief overview of Kawa's compilation process</h2>
<p>In Kawa there are mainly five compilation stages <span class="citation">[<a href="#ref-Bothner1998">40</a>]</span>:</p>
<ol style="list-style-type: decimal">
<li><p>Syntactic analysis - the first compilation stage reads the source input. The result is one or more Scheme forms (S-expressions), represented as lists.</p></li>
<li><p>Semantic analysis - the main source form is rewritten into a set of nested <code>Expression</code> objects, which represents Kawa's <em>abstract syntax tree</em> (AST). For instance, a <code>QuoteExp</code> represents a literal, or a quoted form, a <code>ReferenceExp</code> is a reference to a named variable, an <code>ApplyExp</code> is an application of a procedure func to an argument list and a <code>LetExp</code> is used for let binding forms. The Scheme primitive syntax lambda is translated into a <code>LambdaExp</code>. Other sub-classes of <code>Expression</code> are <code>IfExp</code>, used for conditional expressions, <code>BeginExp</code>, used for compound expressions and <code>SetExp</code>, used for assignments. The top-level <code>Expression</code> object is a <code>ModuleExp</code> and can be considered the root of the AST. This stage also handles macro expansion and lexical name binding.</p></li>
<li><p>Optimisation - an intermediate pass performs type-inference and various optimisation, such as constant folding, dead code elimination and function inlining.</p></li>
<li><p>Code generation - the <code>ModuleExp</code> object is translated into one or more byte-coded classes. This is done by invoking a <code>compile</code> method recursively on the <code>Expression</code>s, which generates JVM instructions using the bytecode package, writing out the resulting class files.</p></li>
<li><p>Loading - if the code is compiled and then immediately executed, the compiled code can be immediately turned into Java classes using the Java <code>ClassLoader</code> feature. Then the bytecode can be loaded into the Kawa run-time.</p></li>
</ol>
<h2 id="a-normalization-1">A-Normalization</h2>
<p>I created a new <code>ExpVisitor</code> that manipulates the syntax tree implementing the transformation to ANF, already described in chapter 3. An <code>ExpVisitor</code> is Java class that can be extended to implement code that traverses the AST to apply a certain transformation. The new visitor, called <code>ANormalize</code>, performs the A-normalization pass just before the optimisation stage of the compiler.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">[<span class="kw">... </span>parsing ...]

ANormalize.<span class="fu">aNormalize</span>(mexp, <span class="kw">this</span>); <span class="co">// &lt;-- A-normalization</span>
InlineCalls.<span class="fu">inlineCalls</span>(mexp, <span class="kw">this</span>);
ChainLambdas.<span class="fu">chainLambdas</span>(mexp, <span class="kw">this</span>);
FindTailCalls.<span class="fu">findTailCalls</span>(mexp, <span class="kw">this</span>);

[<span class="kw">... </span>code generation  ...]</code></pre></div>
<p>At first, we call the visit function on root of the AST, passing as context the identity function.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">aNormalize</span>(Expression exp, Compilation comp) {
    [...]
    visitor.<span class="fu">visit</span>(exp, identity);
}</code></pre></div>
<p>The core of the A-normalizer is the <code>bind</code> function, already introduced in Chapter 3, here called <code>normalizeName</code>. <code>normalizeName</code> creates a new context, then it will visit the expression with this new context. If the passed expression is atomic (cannot be further normalized), like a literal or an identifier, the new context calls the old context with the expression as input. Otherwise it creates a new <code>let</code> expression, binds the expression to a new variable in the <code>let</code> (with <code>genLetDeclaration</code>), then replaces every occurrence of the expression in the code with a reference to the just created variable (with <code>context.invoke(new ReferenceExp(decl))</code>).</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">protected</span> Expression <span class="fu">normalizeName</span>(Expression exp,
                                   <span class="dt">final</span> Context context) {
    Context newContext = <span class="kw">new</span> Context() {
        <span class="fu">@Override</span>
        Expression <span class="fu">invoke</span>(Expression expr) {
            <span class="kw">if</span> (<span class="fu">isAtomic</span>(expr))
                <span class="kw">return</span> context.<span class="fu">invoke</span>(expr);
            <span class="kw">else</span> {
                <span class="co">// create a new Let</span>
                LetExp newlet = <span class="kw">new</span> <span class="fu">LetExp</span>();

                <span class="co">// create a new declaration in the let, using</span>
                <span class="co">// the new expression value</span>
                Declaration decl = <span class="fu">genLetDeclaration</span>(expr, newlet);

                <span class="co">// occurrences of expr in the next computation are</span>
                <span class="co">// referenced using the new declaration</span>
                newlet.<span class="fu">body</span> = context.<span class="fu">invoke</span>(<span class="kw">new</span> <span class="fu">ReferenceExp</span>(decl));
                <span class="kw">return</span> newlet;
            }
        }
    };

    <span class="kw">return</span> <span class="fu">visit</span>(exp, newContext);
}</code></pre></div>
<p>When the expression to normalize is a conditional, as its branches cannot be evaluated before the test outcome, we use <code>normalizeName</code> on each branch expression. Instead of creating a new variable for each branch, we restart the normalization in each branch.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">protected</span> Expression <span class="fu">visitIfExp</span>(<span class="dt">final</span> IfExp exp,
                                <span class="dt">final</span> Context context) {
    Context newContext = <span class="kw">new</span> Context() {

        <span class="fu">@Override</span>
        Expression <span class="fu">invoke</span>(Expression expr) {
            exp.<span class="fu">then_clause</span> = <span class="fu">normalizeTerm</span>(exp.<span class="fu">then_clause</span>);
            exp.<span class="fu">else_clause</span> = (exp.<span class="fu">else_clause</span> != <span class="kw">null</span>)
                              ? <span class="fu">normalizeTerm</span>(exp.<span class="fu">else_clause</span>)
                              : <span class="kw">null</span>;

            exp.<span class="fu">test</span> = expr;

            <span class="kw">return</span> context.<span class="fu">invoke</span>(exp);
        }
    };
    <span class="kw">return</span> <span class="fu">normalizeName</span>(exp.<span class="fu">test</span>, newContext);
}</code></pre></div>
<p>When an atomic expression is encountered in the tree, the passed context is directly invoked with expression passed as argument. At this point the chain of context invocations starts to wrap each expression in a let binding, traversing the AST backward, nesting each non atomic expression in a new <code>let</code>.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">protected</span> Expression <span class="fu">visitQuoteExp</span>(QuoteExp exp,
                                   Context context) {
    <span class="kw">return</span> context.<span class="fu">invoke</span>(exp);
}

<span class="kw">protected</span> Expression <span class="fu">visitReferenceExp</span>(ReferenceExp exp,
                                       Context context) {
    <span class="kw">return</span> context.<span class="fu">invoke</span>(exp);
}</code></pre></div>
<h2 id="code-fragmentation-1">Code fragmentation</h2>
<p>Another <code>ExpVisitor</code>, <code>FragmentAndInstrument</code>, performs the fragmentation and the instrumentation. As described in Chapter 3, the new visitor transforms the code in a sequence function calls. At the same time it wraps in a <code>try-catch</code> expression every atomic computation it encounters in the traversing. This stage is inserted between the A-normalization and the optimisation pass.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">[<span class="kw">... </span>parsing ...]

ANormalize.<span class="fu">aNormalize</span>(mexp, <span class="kw">this</span>);
FragmentAndInstrument.<span class="fu">fragmentCode</span>(mexp, <span class="kw">this</span>);<span class="co">// &lt;-- fragmentation</span>
                                              <span class="co">//and instrumentation</span>
InlineCalls.<span class="fu">inlineCalls</span>(mexp, <span class="kw">this</span>);
ChainLambdas.<span class="fu">chainLambdas</span>(mexp, <span class="kw">this</span>);
FindTailCalls.<span class="fu">findTailCalls</span>(mexp, <span class="kw">this</span>);

[<span class="kw">... </span>code generation ...]</code></pre></div>
<p>The transformation starts at the root of the AST (a <code>ModuleExp</code>), and continues analysing each node of the tree recursively. The most relevant method in <code>FragmentAndInstrument</code> is <code>visitLetExp</code>, which deals with the transformation of <code>let</code> expressions.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">protected</span> Expression <span class="fu">visitLetExp</span>(LetExp exp, Void ignored) {
    Declaration letDecl = exp.<span class="fu">firstDecl</span>();
    Expression nextExp = exp.<span class="fu">body</span>;
    Expression continueValue = letDecl.<span class="fu">getInitValue</span>();</code></pre></div>
<p>After A-normalization the code is mainly made by nested <code>let</code> expression that bind to a variable every atomic computation. <code>visitLetExp</code> takes a <code>LetExp</code> and transforms it in two closures, applying the first to the second one. The former closure executes an atomic computation and calls the latter closure. The latter closure contains the original body of the <code>let</code> expression, which will be further fragmented. Using the example from Chapter 3:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    ((<span class="kw">lambda</span> (incr_an1)        <span class="co">;   &lt;--   closure #1</span>
      (<span class="kw">let</span> ((v1 (<span class="kw">lambda</span> (k)
                  (<span class="kw">let</span> ((v0 (set! incr k)))
                    <span class="dv">0</span>))))
         (incr_an1 v1)))
     (<span class="kw">lambda</span> (v1)              <span class="co">;  &lt;--   closure #2</span>
       ((<span class="kw">lambda</span> (incr_an2)
          (<span class="kw">let</span> ((v2 (<span class="kw">call/cc</span> v1)))
            (incr_an2 v2)))
        (<span class="kw">lambda</span> (v2)
          (<span class="kw">+</span> v2 <span class="dv">1</span>)))))</code></pre></div>
<p>The following code creates the first closure. It simply generates a new lambda expression that takes an argument. The original <code>LetExp</code> becomes the body of the lambda.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">Declaration nextFragmentDecl = <span class="kw">new</span> <span class="fu">Declaration</span>(<span class="st">&quot;continue-fragment&quot;</span>);
LambdaExp fragment = <span class="kw">new</span> <span class="fu">LambdaExp</span>(<span class="dv">1</span>);
fragment.<span class="fu">body</span> = exp;
fragment.<span class="fu">addDeclaration</span>(nextFragmentDecl);</code></pre></div>
<p>We replace the let body with the call to the next fragment, that is <code>(incr_an1 v1)</code> in the previous Scheme example.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">exp.<span class="fu">body</span> = <span class="kw">new</span> <span class="fu">ApplyExp</span>(applyRef,
                        <span class="kw">new</span> <span class="fu">ReferenceExp</span>(nextFragmentDecl),
                        <span class="kw">new</span> <span class="fu">ReferenceExp</span>(letDecl));</code></pre></div>
<p>The code that creates the second closure is very similar to which that generates the first one. It is another new lambda expression that takes an argument. The body this time is the body of the original <code>LetExp</code>.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">Declaration continueValueDecl = <span class="kw">new</span> <span class="fu">Declaration</span>(<span class="st">&quot;continue-value&quot;</span>);
LambdaExp nextFragment = <span class="kw">new</span> <span class="fu">LambdaExp</span>(<span class="dv">1</span>);
nextFragment.<span class="fu">body</span> = nextExp;
nextFragment.<span class="fu">addDeclaration</span>(continueValueDecl);</code></pre></div>
<p>We create a new function call, which applies the first lambda to the second one.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    ((<span class="kw">lambda</span> (incr_an1)        <span class="co">;   &lt;--   closure #1</span>
      ...)
     (<span class="kw">lambda</span> (v1)              <span class="co">;  &lt;--   closure #2</span>
       ...))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">ApplyExp fragmentCall = <span class="kw">new</span> <span class="fu">ApplyExp</span>(fragment,
                                     nextFragment);</code></pre></div>
<p>Then we can move one to annotate with a <code>try-catch</code> the <code>let</code> binding (see next section), and to traverse the rest of the tree calling visit on the body of the second lambda.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">Expression annotatedExp = <span class="fu">visitAndAnnotate</span>(continueValue,
                                           nextFragmentDecl);
letDecl.<span class="fu">setInitValue</span>(annotatedExp);

<span class="co">// visit the rest of the code.</span>
nextFragment.<span class="fu">body</span> = <span class="fu">visit</span>(nextFragment.<span class="fu">body</span>, ignored);

<span class="kw">return</span> fragmentCall;</code></pre></div>
<h2 id="code-instrumentation-1">Code Instrumentation</h2>
<p>First of all, each top level expression is wrapped inside a <code>TopLevelHandler</code> call, which surrounds the expression with an exception handler, as seen in Chapter 3.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">protected</span> Expression <span class="fu">visitModuleExp</span>(ModuleExp exp, Void ignored) {

    <span class="kw">if</span> (exp.<span class="fu">body</span> <span class="kw">instanceof</span> ApplyExp
        &amp;&amp; ((ApplyExp)exp.<span class="fu">body</span>).<span class="fu">isAppendValues</span>()) {
        ApplyExp body = ((ApplyExp)exp.<span class="fu">body</span>);
        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; body.<span class="fu">args</span>.<span class="fu">length</span>; i++) {
            body.<span class="fu">args</span>[i] = <span class="fu">installTopLevelHandler</span>(<span class="fu">visit</span>(body.<span class="fu">args</span>[i],
                                                        ignored));
        }
        <span class="kw">return</span> exp;
    }

    exp.<span class="fu">body</span> = <span class="fu">installTopLevelHandler</span>(<span class="fu">visit</span>(exp.<span class="fu">body</span>, ignored));

    <span class="kw">return</span> exp;
}</code></pre></div>
<p>Then we perform the main part of instrumentation in the <code>visitAndAnnotate</code> method, which we call on every <code>let</code> binding, as shown in the previous section. In <code>visitAndAnnotate</code>, we create a <code>TryExp</code> and an exception handler that catches <code>ContinuationException</code>s.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">private</span> Expression <span class="fu">visitAndAnnotate</span>(Expression exp,
                                    Declaration nextFragmentDecl) {
    TryExp annotatedExp = <span class="kw">new</span> <span class="fu">TryExp</span>(exp, <span class="kw">null</span>);
    Declaration handlerDecl = <span class="kw">new</span> <span class="fu">Declaration</span>((Object) <span class="kw">null</span>,
                                              contExpceptionType);
    ReferenceExp handlerDeclRef = <span class="kw">new</span> <span class="fu">ReferenceExp</span>(handlerDecl);</code></pre></div>
<p>We also create the frame needed to extend the <code>ContinuationException</code>. The frame computation is a lambda which contains the call to the next fragment. Then we can generate the code to create a <code>ContinuationFrame</code> with the lambda just created. The lambda will be translated to a <code>Procedure</code> object at runtime.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(try-catch (<span class="kw">call/cc</span> v1)             <span class="co">; try/catch</span>
  (cex &lt;ContinuationException&gt;      <span class="co">; handler</span>
    (<span class="kw">let</span> ((f (<span class="kw">lambda</span> (continue-value)
               (incr_an2 continue-value))))
      (cex:extend (&lt;ContinuationFrame&gt; f))
      (throw cex))))                <span class="co">; re-throw</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">Declaration argDecl = <span class="kw">new</span> <span class="fu">Declaration</span>(<span class="st">&quot;continue-value&quot;</span>);
ApplyExp nextFragmentCall = <span class="kw">new</span> ApplyExp
                                 (<span class="kw">new</span> <span class="fu">ReferenceExp</span>(nextFragmentDecl),
                                  <span class="kw">new</span> <span class="fu">ReferenceExp</span>(argDecl));

Expression frame = <span class="fu">createFrame</span>(argDecl, nextFragmentCall);

ApplyExp cframe = <span class="kw">new</span> <span class="fu">ApplyExp</span>(contFrameClass,
                               frame);
ApplyExp extend = <span class="kw">new</span> <span class="fu">ApplyExp</span>(<span class="kw">new</span> <span class="fu">PrimProcedure</span>(<span class="st">&quot;Helpers&quot;</span>,
                                                 <span class="st">&quot;extend&quot;</span>, <span class="dv">2</span>),
                               handlerDeclRef,
                               cframe);</code></pre></div>
<p>The last thing to generate is the re-throw instruction for the caught <code>ContinuationException</code>. Eventually, we visit the annotated exp to continue the tree traversing.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">ApplyExp throwApply = <span class="kw">new</span> <span class="fu">ApplyExp</span>(primitiveThrow,
                                   handlerDeclRef);
Expression begin = <span class="kw">new</span> <span class="fu">BeginExp</span>(extend, throwApply);
annotatedExp.<span class="fu">addCatchClause</span>(handlerDecl, begin);

<span class="co">// visit the wrapped expression</span>
annotatedExp.<span class="fu">try_clause</span> = <span class="fu">visit</span>(annotatedExp.<span class="fu">try_clause</span>, <span class="kw">null</span>);
<span class="kw">return</span> annotatedExp;</code></pre></div>
<h2 id="other-control-operators-delimited-continuations">Other control operators: delimited continuations</h2>
<p>The transformation and the support code described in this Chapter is not only suitable to implement <code>call/cc</code>, but it can also be employed to implement other control operators.</p>
<h3 id="prompts-and-barriers">Prompts and barriers</h3>
<p>A <em>prompt</em> is a special kind of continuation frame that is annotated with a specific tag. Some operations allow to save continuation frames from the capture position out to the nearest enclosing prompt; such a continuation is sometimes called a delimited continuation <span class="citation">[<a href="#ref-EvaluationRacket2015">44</a>]</span>.</p>
<p>A <em>continuation barrier</em> is another kind of continuation frame that prohibits certain replacements of the current continuation with another. A continuation can be replaced by another only when the replacement does not introduce any continuation barriers. A continuation barrier thus prevents to jump into a continuation that is protected by a barrier <span class="citation">[<a href="#ref-EvaluationRacket2015">44</a>]</span>.</p>
<h4 id="call-with-continuation-prompt"><code>call-with-continuation-prompt</code></h4>
<p>I implemented a simple version of the <code>call-with-continuation-prompt</code> procedure. This function installs a prompt, and then it evaluates a given thunk under the prompt. During the dynamic extent of the call to thunk, if a user calls <code>call/cc</code>, the stack will be unwind until the prompt. Thus <code>call/cc</code> will capture a delimited continuation, because it is not the whole continuation of the program; rather, just the computation initiated by the call to <code>call-with-continuation-prompt</code>.</p>
<p>As an example, consider this simple expression:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">define</span><span class="fu"> c </span><span class="dv">#f</span>)

    (* <span class="dv">2</span>
     (<span class="kw">+</span> <span class="dv">3</span> <span class="dv">4</span>
        (<span class="kw">call/cc</span>
         (<span class="kw">lambda</span> (k)
           (set! c k)
           <span class="dv">0</span>)))) <span class="co">; =&gt; 14</span></code></pre></div>
<p>This code is straightforward, it captures a continuation and stores it in the global binding <code>c</code>. The saved continuation looks like this:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (* <span class="dv">2</span> (<span class="kw">+</span> <span class="dv">3</span> <span class="dv">4</span> _))</code></pre></div>
<p>We can apply the continuation as usual:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (c <span class="dv">3</span>) <span class="co">; =&gt; 20</span></code></pre></div>
<p>To capture part of the continuation we can use a prompt. For instance, if we want capture only <code>(+ 3 4 _)</code>:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (* <span class="dv">2</span>
      (call-with-continuation-prompt
        (<span class="kw">lambda</span> ()
          (<span class="kw">+</span> <span class="dv">3</span> <span class="dv">4</span>
            (<span class="kw">call/cc</span>
              (<span class="kw">lambda</span> (k)
                (set! c k)
                <span class="dv">0</span>)))))) <span class="co">; =&gt; 14</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (c <span class="dv">3</span>) <span class="co">; =&gt; 10</span></code></pre></div>
<p>The <code>call-with-continuation-prompt</code> procedure is semantically equivalent to the <code>TopLevelHandler</code> previously described as part of the Kawa <code>call/cc</code> implementation, and can be expressed with a simple macro:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (define-namespace &lt;TLH&gt;
        &lt;gnu.expr.continuations.TopLevelHandler&gt;)

    (<span class="kw">define</span><span class="fu"> </span>(%tlh f)
      (&lt;TLH&gt;:runInTopLevelHandler f))

    (<span class="kw">define-syntax</span><span class="fu"> call-with-continuation-prompt</span>
      (<span class="kw">syntax-rules</span> ()
        ((_ f)
         (%tlh (<span class="kw">lambda</span> (x) (f))))))</code></pre></div>
<p>Other Scheme implementations, such as Racket or Guile, provides an extended version of this procedure that allows to set prompt tags and handlers. That extended version could be in theory implemented in Kawa modifying <code>TopLevelHandler</code> to support custom handlers.</p>
<h4 id="call-with-continuation-barrier"><code>call-with-continuation-barrier</code></h4>
<p>Another procedure that we can provide is <code>call-with-continuation-barrier</code>. It applies a function with a continuation barrier between the application and the current continuation, then returns the result of the function call. Morover, it do not allow the invocation of continuations that would leave or enter the dynamic extent of the call to <code>call-with-continuation-barrier</code>. Such an attempt causes an exception to be thrown.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (define-namespace &lt;CH&gt;
       &lt;gnu.expr.continuations.Helpers&gt;)

    (<span class="kw">define-syntax</span><span class="fu"> call-with-continuation-barrier</span>
      (<span class="kw">syntax-rules</span> ()
        ((_ f)
         (try-catch (f)
           (cex &lt;CH&gt;:ContinuationException
             (cex:extend (&lt;CH&gt;:ContinuationFrame
                             (<span class="kw">lambda</span> (x)
                               (throw (java.lang.Exception
                                        <span class="st">&quot;attempt to cross a</span>
<span class="st">                                         continuation barrier&quot;</span>)))))
             (throw cex))))))</code></pre></div>
<p>The macro replaces the call to <code>call-with-continuation-barrier</code> with an exception handler that intercepts <code>ContinuationException</code>s. The exception handler extends the continuation with a new frame that when invoked throws an exception. Then re-throws the original <code>ContinuationException</code> so that the original <code>call/cc</code> call is not affected.</p>
<p>If we try the previous example using this time a continuation barrier, we get an error:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (* <span class="dv">2</span>
      (call-with-continuation-barrier
        (<span class="kw">lambda</span> ()
          (<span class="kw">+</span> <span class="dv">3</span> <span class="dv">4</span>
            (<span class="kw">call/cc</span>
              (<span class="kw">lambda</span> (k)
                (set! c k)
                <span class="dv">0</span>)))))) <span class="co">; =&gt; 14</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (c <span class="dv">3</span>) <span class="co">; =&gt; java.lang.Exception: attempt to cross a</span>
          <span class="co">;                          continuation barrier</span></code></pre></div>
<h3 id="shift-and-reset"><code>shift</code> and <code>reset</code></h3>
<p>I introduced <code>shift</code> and <code>reset</code> operators and delimited continuations in Chapter 1. <code>call/cc</code> can be used to implement those two operators, as shown by Filinsky et al. in <span class="citation">[<a href="#ref-Filinski1994">45</a>]</span>. The following code is a port of their SML/NJ implementation:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">define</span><span class="fu"> </span>(escape f)
      (<span class="kw">call/cc</span> (<span class="kw">lambda</span> (k)
                 (f (<span class="kw">lambda</span> x
                      (apply k x))))))

    (<span class="kw">define</span><span class="fu"> mk </span><span class="dv">#f</span>)

    (<span class="kw">define</span><span class="fu"> </span>(abort x) (mk x))

    (<span class="kw">define</span><span class="fu"> </span>(%reset t)
      (escape (<span class="kw">lambda</span> (k)
                (<span class="kw">let</span> ((m mk))
                  (set! mk (<span class="kw">lambda</span> (r)
                             (set! mk m)
                             (k r)))
                  (abort (t))))))

    (<span class="kw">define</span><span class="fu"> </span>(shift h)
      (escape (<span class="kw">lambda</span> (k)
                (abort (h (<span class="kw">lambda</span> v
                            (%reset (<span class="kw">lambda</span> ()
                                      (apply k v)))))))))

    (<span class="kw">define-syntax</span><span class="fu"> reset</span>
      (<span class="kw">syntax-rules</span> ()
        ((reset <span class="kw">exp</span> ...)
         (%reset (<span class="kw">lambda</span> () <span class="kw">exp</span> ...)))))</code></pre></div>
<h4 id="native-shift-and-reset">Native <code>shift</code> and <code>reset</code></h4>
<p>Although we can implement delimited continuations using <code>call/cc</code>, we can avoid unnecessary overhead implementing <code>shift</code> and <code>reset</code> in Java, modifying the existing <code>call/cc</code> implementation.</p>
<p>The <code>reset</code> function is semantically similar to the <code>TopLevelHandler</code>, while the <code>shift</code> can be seen as a kind of <code>call/cc</code>. The main difference is that the continuation captured by the <code>shift</code> has a limited extent and behaves as an actual function, returning a value. So invoking the continuation inside the <code>shift</code> call does not have the effect of escaping from the procedure.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> Shift <span class="kw">extends</span> Procedure1 {

    [...]

    <span class="kw">public</span> <span class="dt">static</span> Object <span class="fu">shift</span>(<span class="dt">final</span> Procedure receiver)
        <span class="kw">throws</span> ContinuationException {
        <span class="kw">try</span> {
            <span class="co">// begin unwind the stack</span>
            <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">DelimitedContinuationException</span>();
        } <span class="kw">catch</span> (DelimitedContinuationException sce) {
            sce.<span class="fu">extend</span>(<span class="kw">new</span> <span class="fu">ContinuationFrame</span>(receiver));
            <span class="kw">throw</span> sce;
        }
    }
}</code></pre></div>
<p>The <code>Shift</code> class works like the <code>CallCC</code> one, bu it throws a different type of exception, i.e. a <code>DelimitedContinuationException</code>, that does not interfere with the <code>call/cc</code> calls.</p>
<p>The <code>Reset</code> extends <code>TopLevelHandler</code> to implement its functionality. In this case there is no need to run the <code>try</code>/<code>catch</code> block in a loop, because of the different nature of delimited continuations. As they can be considered regular functions this handler does not need to catch an <code>ExitException</code>, it only need to manage the <code>DelimitedContinuationException</code> thrown by the <code>shift</code> call.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> Reset <span class="kw">extends</span> TopLevelHandler {

    [...]

    <span class="kw">public</span> <span class="dt">static</span> Object <span class="fu">runInTopLevelHandler</span>(Procedure initialFrame)
        <span class="kw">throws</span> Throwable {
        <span class="kw">try</span> {
            <span class="kw">return</span> initialFrame.<span class="fu">apply1</span>(<span class="kw">null</span>);
        } <span class="kw">catch</span> (DelimitedContinuationException dce) {
            <span class="dt">final</span> Continuation k = dce.<span class="fu">toContinuation</span>();
            <span class="kw">return</span> k.<span class="fu">resume</span>(k);
        }
    }
}</code></pre></div>
<p>The <code>DelimitedContinuation</code> object is different from a <code>Continuation</code> in that it does not throw an exception, but it returns a value. Moreover, the apply method reloads the frames inside a <code>reset</code> to handle possible future calls of <code>shift</code> inside the original outer <code>reset</code>.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> DelimitedContinuation <span class="kw">extends</span> Continuation {

    [...]

    <span class="kw">public</span> Object <span class="fu">apply1</span>(<span class="dt">final</span> Object val) <span class="kw">throws</span> Throwable {
        Procedure1 t = <span class="kw">new</span> <span class="fu">Procedure1</span>() {

            <span class="fu">@Override</span>
            <span class="kw">public</span> Object <span class="fu">apply1</span>(Object arg1) <span class="kw">throws</span> Throwable {
                <span class="kw">return</span> <span class="fu">reloadFrames</span>(<span class="dv">0</span>, frames.<span class="fu">size</span>() - <span class="dv">2</span>, val);
            }
        };

        <span class="kw">return</span> Reset.<span class="fu">runInTopLevelHandler</span>(t);
    }</code></pre></div>
<h3 id="selective-transformation">Selective transformation</h3>
<p>Using delimited continuations instead of un-delimited ones, gives us the chance to avoid transforming the whole source code. For instance, if we use <code>reset</code>/<code>shift</code> in a small portion of a program, we can transform only that portion an leave the rest untouched.</p>
<p>The following code is a basic implementation of this idea. The two macros transform the code starting from a <code>call-with-continuation-prompt</code> call. The first macro marks the code to be processed by a successive pass. Then the <code>call/cc-rewrite</code> macro operates on the syntax tree performing the A-normalization pass and the instrumentation pass on the expression. This gives us continuation-enabled code enclosed in the <code>call-with-continuation-prompt</code>.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (define-namespace &lt;TLH&gt; &lt;gnu.expr.continuations.TopLevelHandler&gt;)
    (define-namespace &lt;ANF&gt; &lt;gnu.expr.ANormalize&gt;)
    (define-namespace &lt;FAI&gt; &lt;gnu.expr.FragmentAndInstrument&gt;)
    (define-namespace &lt;COMP&gt; &lt;gnu.expr.Compilation&gt;)

    (<span class="kw">define</span><span class="fu"> </span>(%tlh f)
      (&lt;TLH&gt;:runInTopLevelHandler f))

    (<span class="kw">define-syntax</span><span class="fu"> call-with-continuation-prompt</span>
      (<span class="kw">syntax-rules</span> ()
        ((_ f)
         (%tlh (call/cc-rewrite (<span class="kw">lambda</span> (x) (f)))))))

    (define-rewrite-syntax call/cc-rewrite
      (<span class="kw">lambda</span> (x)
        (syntax-case x ()
          ((_ sexp)
           (<span class="kw">let</span> ((<span class="kw">exp</span> (syntax-&gt;expression (syntax sexp))))
             (&lt;ANF&gt;:aNormalize <span class="kw">exp</span> (&lt;COMP&gt;:getCurrent))
             (&lt;FAI&gt;:fragmentCode <span class="kw">exp</span> (&lt;COMP&gt;:getCurrent))
             <span class="kw">exp</span>)))))</code></pre></div>
<p>This concept can be further developed, to support nested prompts, and to achieve something similar to what Rompf et al. did in <span class="citation">[<a href="#ref-Rompf2009">23</a>]</span> for the Scala compiler.</p>
<h2 id="higher-order-functions">Higher order functions</h2>
<p>To support the capture of continuations inside higher order functions, it is possible to add them, or at least the most common ones, in a module that is transformed for <code>call/cc</code> support end included in the compiler. I defined a Scheme version of <code>map</code> and <code>for-each</code>, which I added in the standard library of Kawa to experiment the applicability of this technique. The module in which those functions are implemented is compiled with the continuations transformation enabled (this can be done using <code>(module-compile-options full-continuations: #t)</code>). Moreover, when a Scheme source file is compiled with the full <code>call/cc</code> enabled, the compiler replaces the higher order functions with the instrumented version. This allows to capture continuations inside those functions.</p>
<h1 id="case-studies">Case studies</h1>
<blockquote>
<em>“Who controls the past controls the future. He who controls the present controls the past.”</em>
<p class="citright">
George Orwell, 1984
</p>
</blockquote>
<h2 id="asynchronous-programming-async-and-await">Asynchronous programming: Async and Await</h2>
<p>Asynchronous programming is a programming paradigm that facilitates fast and responsive applications. Asynchronous programming is crucial to avoid the inefficiencies caused by blocking activities, such as accesses to the web. Access to a web resource or to a huge database can be slow or delayed. If such an activity is blocked within a synchronous process, the entire application is stuck. You can avoid performance bottlenecks and enhance the responsiveness of your application by using asynchronous programming. In an asynchronous process, the application can continue with other work that does not depend on the resource to be accessed until the potentially blocking task finishes. However, traditional techniques for writing asynchronous applications can be complicated, making them difficult to write, debug, and maintain. In this section, I propose a syntax similar to the <code>async</code>/<code>await</code> construct already introduced in C#, that allows to execute asynchronous tasks during the normal execution of the program.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">define</span><span class="fu"> </span>(&lt;async-call&gt; &lt;arg&gt;*)
      ... long running operation
          that returns an int ...)

    (async (&lt;async-call&gt; &lt;arg&gt;*)
      ... work independent to the
          int result here  ...
      (await &lt;var&gt; <span class="co">; &lt;- wait for the result</span>
        ... here you can use ...
        ... the result, contained in &lt;var&gt; ...))</code></pre></div>
<p>We will also see how asynchronous programming features can be added to Scheme using coroutines and delimited continuations.</p>
<h3 id="coroutines">Coroutines</h3>
<p>Coroutines are functions that can be paused and later resumed. They are necessary to build lightweight threads because they provide the ability to change execution context. Coroutines are considered challenging to implement on the JVM, as they are usually implemented using bytecode instrumentation. However, first-class continuations makes painless to implement coroutines. They can indeed be obtained with few lines of code in Scheme. The following code is a port of safe-for-space cooperative threads presented by Biagioni et al. in <span class="citation">[<a href="#ref-biagioni1998safe">46</a>]</span>, where the code for managing a queue has been omitted for brevity:</p>
<p></p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> process-queue</span>
           (make-queue))
(<span class="kw">define</span><span class="fu"> sync-cont </span><span class="dv">#f</span>)

(<span class="kw">define</span><span class="fu"> </span>(coroutine thunk)
  (enqueue! process-queue thunk))

(<span class="kw">define</span><span class="fu"> </span>(dispatch)
  (<span class="kw">if</span> (<span class="kw">null?</span> (<span class="kw">car</span> process-queue))
    (when sync-cont
        (sync-cont))
    ((dequeue! process-queue))))


(<span class="kw">define</span><span class="fu"> </span>(exit)
  (dispatch))

(<span class="kw">define</span><span class="fu"> </span>(sync)
  (<span class="kw">call/cc</span>
   (<span class="kw">lambda</span> (k)
     (set! sync-cont k)
     (dispatch))))</code></pre></div>
<p></p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">  (<span class="kw">define</span><span class="fu"> </span>(yield)
    (<span class="kw">call/cc</span>
     (<span class="kw">lambda</span> (parent)
       (coroutine (<span class="kw">lambda</span> ()
                    (parent <span class="dv">#f</span>)))
       (dispatch))))

  (<span class="kw">define</span><span class="fu"> </span>(thread-activator)
    (<span class="kw">call/cc</span>
     (<span class="kw">lambda</span> (parent)
       (<span class="kw">let</span> ((f (<span class="kw">call/cc</span>
                 (<span class="kw">lambda</span> (fc)
                  (parent fc)))))
         (f)
         (exit)))))

  (<span class="kw">define</span><span class="fu"> </span>(fork f)
    (<span class="kw">call/cc</span>
     (<span class="kw">lambda</span> (parent)
       (coroutine (<span class="kw">lambda</span> ()
                    (parent <span class="dv">#f</span>)))
       ((thread-activator) f))))</code></pre></div>
<p></p>
<p>The function <code>coroutine</code> establishes a context for running the passed thunk; the <code>fork</code> function starts the execution of a new coroutine. The implementation uses an internal prompt (<code>thread-activator</code>) to establish the scope of the coroutine. The state of a running coroutine is saved as a function in the queue when doing a <code>yield</code>, then the next coroutine in the queue is started by <code>dispatch</code>. To end a process, we can call the <code>exit</code> function, which calls <code>dispatch</code> without saving the current process in the queue. <code>sync</code> allows to wait until all the processes are finished.</p>
<p>Control operators like <code>call/cc</code> make the implementation of coroutines simpler because one can separate the management of queues from the processes. Coroutines are used in different applications, because they make certain concurrent computations much easier to express and easier to understand, and because, when the number of threads is high, the can give a significant performance improvement over native threads.</p>
<h3 id="async-with-coroutines">Async with coroutines</h3>
<p>With the availability of coroutines and <code>reset</code>/<code>shift</code> we can implement an <code>async</code>/<code>await</code> expression in Scheme with few lines of code:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">define-syntax</span><span class="fu"> async</span>
      (<span class="kw">syntax-rules</span> (await)
        ((async call during-exp ...
           (await var after-exp ...))
         (<span class="kw">let</span> ((var <span class="dv">#f</span>))
            (reset
              (shift (<span class="kw">lambda</span> (k)
                      (k)
                      (fork (<span class="kw">lambda</span> () <span class="co">; &lt;- start coroutine</span>
                              (set! var call)
                              (exit)))))
              (fork (<span class="kw">lambda</span> () during-exp ... (exit))))
            (sync) <span class="co">; &lt;- wait until all coroutines finish</span>
            after-exp ...))))</code></pre></div>
<p>Consider the following example. We need to execute a time consuming function call, which can be a loop or a recursive function processing some data, but we would like to do something else in the meantime.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">define</span><span class="fu"> </span>(long-call)
      (<span class="kw">let</span> loop ((x <span class="dv">1</span>))
        (<span class="kw">if</span> (<span class="kw">&lt;</span> x <span class="dv">100</span>)
          (<span class="kw">begin</span> (yield)
                 (<span class="kw">display</span> x)
                 (<span class="kw">newline</span>)
                 (loop (<span class="kw">+</span> x <span class="dv">1</span>)))
          <span class="dv">42</span>)))</code></pre></div>
<p>Calling the long call with the <code>async</code> syntax it is possible to execute other code in a concurrent way. We can put <code>(yield)</code> call inside the loop to suspend the execution and resume the next coroutine in the queue. We do the same in the code to be executed at the same time. The effect is that of running two tasks at the same time. The <code>await</code> keyword allows to wait for the result of the long call, which is bound to the specified variable (<code>x</code> in this example).</p>
<p>The logic is implemented using coroutines, the two expressions to be run concurrently are launched using a <code>fork</code>, while the result is awaited using <code>sync</code>. <code>reset</code>/<code>shift</code> allows us to delimit the extent of the continuation to be captured, and to change the order of the executed code.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">display</span> <span class="st">&quot;start async call&quot;</span>)
    (<span class="kw">newline</span>)
    (async (long-call)
           (<span class="kw">display</span> <span class="st">&quot;do other things in the meantime...&quot;</span>)
           (<span class="kw">newline</span>)
           (<span class="kw">let</span> loop ((x <span class="dv">0</span>))
             (when (<span class="kw">&lt;</span> x <span class="dv">100</span>)
               (<span class="kw">begin</span> (yield)
                      (<span class="kw">display</span> (<span class="kw">-</span> x))
                      (<span class="kw">newline</span>)
                      (loop (<span class="kw">+</span> x <span class="dv">1</span>)))))
           (<span class="kw">newline</span>)
      (await x
        (<span class="kw">display</span> <span class="st">&quot;result -&gt; &quot;</span>)
        (<span class="kw">display</span> x)
        (<span class="kw">newline</span>)))</code></pre></div>
<p>The above code prints:</p>
<pre><code>    start async call
    do other things in the meantime...
    0
    1
    -1
    2
    -2
    [...]
    98
    -98
    99
    -99

    result -&gt; 42
</code></pre>
<h3 id="async-with-threads">Async with threads</h3>
<p>Using threads instead of coroutine we can avoid adding <code>(yield)</code> calls in our code, maintaining the same syntax. Kawa provides a simple interface to create parallel threads: <code>(future expression)</code> creates a new thread that evaluates <code>expression</code>, while <code>(force thread)</code> waits for the thread’s expression to finish executing, and returns the result. Kawa threads are implemented using Java threads.</p>
<p>Thus we can remove <code>(yield)</code> calls from our code and redefine the <code>async</code>/<code>await</code> syntax to use Kawa threads:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">define-syntax</span><span class="fu"> async</span>
      (<span class="kw">syntax-rules</span> (await)
        ((async call during-exp ...
           (await var after-exp ...))
         (<span class="kw">let</span> ((var <span class="dv">#f</span>))
            (reset
             (shift (<span class="kw">lambda</span> (k)
                  (set! var (future call)) <span class="co">; &lt;- start thread</span>
                  (k)))
             during-exp ...)
            (set! var (<span class="kw">force</span> var)) <span class="co">; &lt;- wait for result</span>
            after-exp ...))))</code></pre></div>
<p>Now the two tasks are run in parallel, and their printed output is not deterministic:</p>
<pre><code>    start async call
    do other things in the meantime...
    0
    -1
    1
    2
    -2
    [...]
    98
    99
    -98
    -99

    result -&gt; 42
</code></pre>

<h2 id="kawa-debugger">Kawa debugger</h2>
<p>Instrumentation allows to suspend the execution of a program, store its state, and resume it, even multiple times. Thus, we can exploit the instrumentation performed to obtain first-class continuations in Kawa to implement debugging features. I extended the technique described in Chapters 3-4 to implement a simple debugger.</p>
<p>When you enable the debugging mode, the compiler instruments each atomic expression with debugging calls, and generates code to store variable bindings in an internal table. When the resulting code runs, it stops at breakpoints and lets you step through the program and inspect variables.</p>
<p>As an example, suppose we need to debug this snippet of code:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    <span class="dv">1</span> (<span class="kw">define</span><span class="fu"> </span>(get-first pred lst)
    <span class="dv">2</span>   (<span class="kw">call/cc</span>
    <span class="dv">3</span>     (<span class="kw">lambda</span> (return)
    <span class="dv">4</span>       (<span class="kw">for-each</span> (<span class="kw">lambda</span> (x)
    <span class="dv">5</span>                   (<span class="kw">if</span> (pred x)
    <span class="dv">6</span>                     (return x)))
    <span class="dv">7</span>                     lst)
    <span class="dv">8</span>     <span class="dv">#f</span>)))
    <span class="dv">9</span>
   <span class="dv">10</span> (get-first <span class="kw">negative?</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> -<span class="dv">5</span> <span class="dv">6</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">9</span>)) <span class="co">; =&gt; -5</span></code></pre></div>
<p>We can add a pausing instruction simply calling the <code>breakpoint</code> function, as you can see below:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    ...
        (<span class="kw">for-each</span> (<span class="kw">lambda</span> (x)
                     (breakpoint) <span class="co">; &lt;--</span>
                     (<span class="kw">if</span> (pred x)
    ...</code></pre></div>
<p>Once the program is run the execution stops at the breakpoint line, opening a terminal that accepts some predefined commands. The following commands are supported:</p>
<table>
<thead>
<tr class="header">
<th align="left">command</th>
<th align="left">result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">s(tep)</td>
<td align="left">run for one step</td>
</tr>
<tr class="even">
<td align="left">c(ontinue)</td>
<td align="left">run until the next breakpoint</td>
</tr>
<tr class="odd">
<td align="left">p(rint) [var]</td>
<td align="left">print a variable</td>
</tr>
<tr class="even">
<td align="left">q(uit)</td>
<td align="left">exit the program</td>
</tr>
</tbody>
</table>
<p>The following listing shows a session of the debugger. In this case the user prints some variable values, then steps forward two times, executing one atomic expression at each step, then continues to stop at the breakpoint at each cycle of the <code>for-each</code> until the function returns:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    ### suspended at line <span class="dv">5</span> ###
    <span class="kw">&gt;</span> print x
    | x: <span class="dv">1</span>
    <span class="kw">&gt;</span> print return
    | return: #&lt;continuation&gt;
    <span class="kw">&gt;</span> step
    ### suspended at line <span class="dv">6</span> ###
    ### after expression
    (Apply line:<span class="dv">6</span>:<span class="dv">8</span> (Ref/<span class="dv">24</span>/Declaration[applyToArgs/<span class="dv">2</span>])
      (Ref/<span class="dv">23</span>/Declaration[pred/<span class="dv">101</span>])
      (Ref/<span class="dv">25</span>/Declaration[x/<span class="dv">135</span>]))
    ###
    <span class="kw">&gt;</span> step
    ### suspended at line <span class="dv">5</span> ###
    <span class="kw">&gt;</span> print x
    | x: <span class="dv">2</span>
    <span class="kw">&gt;</span> <span class="kw">continue</span>
    ### suspended at line <span class="dv">5</span> ###
    <span class="kw">&gt;</span> <span class="kw">continue</span>
    ### suspended at line <span class="dv">5</span> ###
    <span class="kw">&gt;</span> print x
    | x: <span class="dv">4</span>
    <span class="kw">&gt;</span> print #all
    | get-first: #&lt;procedure get-first&gt;
    | pred: #&lt;procedure negative?&gt;
    | x: <span class="dv">4</span>
    | lst: (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> -<span class="dv">5</span> <span class="dv">6</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">9</span>)
    | return: #&lt;continuation&gt;
    ### suspended at line <span class="dv">5</span> ###
    <span class="kw">&gt;</span> <span class="kw">continue</span>
    -<span class="dv">5</span></code></pre></div>
<h3 id="implementation-details">Implementation details</h3>
<p>The debugger works adding suspension instruction between each atomic expression. After A-normalisation the code is already transformed in a form suitable for instrumentation. During the fragmentation and instrumentation pass, needed by <code>call/cc</code>, the syntax tree visitor adds the debug instructions. When the execution reaches a breakpoint call the program is suspended and the user can insert his commands.</p>
<p>The breakpoint call also enables the step mode. Suspension instructions between atomic expressions are disabled during the normal execution, but they are activated when the user gives the <code>step</code> command. When the step mode is on, the program stops at each atomic instruction running a simple REPL. When the user gives the <code>continue</code> command, the step mode is disabled and the programs can run until the next breakpoint call.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">define</span><span class="fu"> </span>(breakpoint . args)
      (dbg:enableStepMode)
      (suspend (<span class="kw">car</span> args) (<span class="kw">cadr</span> args)))

    (<span class="kw">define</span><span class="fu"> </span>(suspend line sourceLine)
      (when dbg:stepMode
        (<span class="kw">begin</span>
          (dbg:printInfo line sourceLine (<span class="kw">current-output-port</span>))
          (<span class="kw">let</span> loop ()
            (<span class="kw">let*</span> ((in (read-line))
                   (cmds ((in:toString):split <span class="st">&quot; &quot;</span>))
                   (cmd (<span class="kw">string-&gt;symbol</span> (cmds <span class="dv">0</span>))))
              (<span class="kw">case</span> cmd
                ((c <span class="kw">continue</span>) (dbg:disableStepMode))
                ((p print)
                 (<span class="kw">if</span> (<span class="kw">&gt;</span> cmds:length <span class="dv">1</span>)
                   (<span class="kw">begin</span>
                     (print (<span class="kw">string-&gt;symbol</span> (cmds <span class="dv">1</span>)))
                     (loop))))
                ((s step) (void))
                ((q quit exit) (exit))
                (<span class="kw">else</span> (<span class="kw">display</span> (<span class="kw">string-append</span>
                                   <span class="st">&quot;unknown command &quot;</span>
                                   (cmds <span class="dv">0</span>)))
                      (<span class="kw">newline</span>)
                      (loop))))))))</code></pre></div>
<p>Regarding the debugging instrumentation, the main part is performed in the <code>visitLetExp</code> method. I generate a new suspend expression, besides another instruction to add the value of the bind variable to the debugger table at runtime. For each let-bind expression, when the user calls the <code>print</code> command, he gets the last value of that variable from the table.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">protected</span> Expression <span class="fu">visitLetExp</span>(LetExp exp, Void ignored) {
    Declaration letDecl = exp.<span class="fu">firstDecl</span>();
    Expression continueValue = letDecl.<span class="fu">getInitValue</span>();
    String symbol = letDecl.<span class="fu">getName</span>();

    <span class="kw">if</span> (Compilation.<span class="fu">enableDebugger</span>) {
        <span class="dt">int</span> lnum = continueValue.<span class="fu">getLineNumber</span>();
        String codeLine = continueValue.<span class="fu">print</span>();;

        <span class="co">// suspension instruction</span>
        ApplyExp suspend = <span class="kw">new</span> <span class="fu">ApplyExp</span>(applyRef,
                                       suspendProc,
                                       <span class="kw">new</span> <span class="fu">QuoteExp</span>(lnum),
                                       <span class="kw">new</span> <span class="fu">QuoteExp</span>(codeLine));

        <span class="co">// add binding to the debugger binding table</span>
        ApplyExp addVar = <span class="kw">new</span> <span class="fu">ApplyExp</span>(applyRef,
                                       addBindingProc,
                                       QuoteExp.<span class="fu">getInstance</span>(symbol),
                                       <span class="kw">new</span> <span class="fu">ReferenceExp</span>(letDecl));

        exp.<span class="fu">body</span> = <span class="kw">new</span> <span class="fu">BeginExp</span>(<span class="kw">new</span> Expression[]{addVar,
                                                 suspend,
                                                 exp.<span class="fu">body</span>});
    }

    ...</code></pre></div>
<h1 id="evaluation">Evaluation</h1>
<blockquote>
<em>“Extraordinary claims require extraordinary evidence.”</em>
<p class="citright">
Carl Sagan, Encyclopedia Galactica
</p>
</blockquote>
<h2 id="transformation-overhead">Transformation overhead</h2>
<p>We saw in the previous chapters how we can implement <code>call/cc</code> in a JVM targeting compiler, performing a transformation on the whole source to instrument the original code. We would like to know how this global transformation impacts the overall performances of the program when no continuations are captured. We already observed that exception handlers are not expensive on the JVM, but there are other variables to take in consideration. The code fragmentation implies an increase on the number of function calls, which can reduce performance.</p>
<p>I used a set of benchmarks to analyse the behaviour of the running code in the case of both transformed code and non-transformed code. All the benchmarks were executed on an Intel i5 dual-core processor with 4GB of RAM (i5-2410M , 2.30GHz).The operating system was Debian GNU/Linux. The table in Figure  and the chart in Figure  show the results.</p>
<div class="figure">
<img src="figures/overhead-table.png" alt="Transformed vs non-transformed code, 10 iterations, values in seconds " />
<p class="caption">Transformed vs non-transformed code, 10 iterations, values in seconds </p>
</div>
<p>The <code>fib</code> benchmark runs a simple Fibonacci function with 30 as input. <code>tak</code> implements the Takeuchi function and runs it with 18, 12, 6. <code>cpstak</code> is a version of <code>tak</code> rewritten in continuation passing style. We can observe that the transformation introduces a considerable overhead, especially in the <code>fib</code> benchmark.</p>
<div class="figure">
<img src="figures/overhead.png" alt="Transformed vs non-transformed code, performance comparison " />
<p class="caption">Transformed vs non-transformed code, performance comparison </p>
</div>
<p>To understand from where this overhead comes from, I profiled the execution of the fib benchmark using HPROF, a profiling tool provided by the Java platform <span class="citation">[<a href="#ref-HPROF2015">47</a>]</span>. Considering the cpu usage data (Figure ), we can observe that approximately 10% of the cpu time is spent allocating <code>Proceure</code> objects (<code>gnu.mapping.Procedure.&lt;init&gt;</code> and <code>gnu.expr.ModuleMethod.&lt;init&gt;</code>).</p>
<div class="figure">
<img src="figures/cpu.png" alt="Most called Java methods in the fib benchmark " />
<p class="caption">Most called Java methods in the <code>fib</code> benchmark </p>
</div>
<div class="figure">
<img src="figures/heap.png" alt="Most allocated Java object during the execution of the fib benchmark " />
<p class="caption">Most allocated Java object during the execution of the <code>fib</code> benchmark </p>
</div>
<p>We can reach the same conclusions analysing the heap usage. Figure  shows which objects are more often allocated during the execution of <code>fib</code>.</p>
<div class="figure">
<img src="figures/mem-overhead-table.png" alt="memory usage in transformed vs non-transformed code, values in Kbytes  " />
<p class="caption">memory usage in transformed vs non-transformed code, values in Kbytes  </p>
</div>
<p>Almost 40% of the heap is used to store object of type <code>ModuleMethodWithContext</code>, that is the runtime object in which closures are allocated. This is not unexpected, as the transformed code is fragmented in a set of closures. However, this suggest that a possible improvement for the technique can be obtained optimising closure allocation.</p>
<div class="figure">
<img src="figures/mem-overhead.png" alt="Transformed vs non-transformed code, memory usage comparison " />
<p class="caption">Transformed vs non-transformed code, memory usage comparison </p>
</div>
<h2 id="callcc-performance"><code>call/cc</code> performance</h2>
<p>I tested the new <code>call/cc</code> implementation on five continuation-intensive benchmarks. <code>fibc</code> is a variation of <code>fib</code> with continuations. The <code>loop2</code> benchmark corresponds to a non-local-exit scenario in which a tight loop repeatedly throws to the same continuation. The <code>ctak</code> benchmark is a continuation-intensive variation of the call-intensive <code>tak</code> benchmark. The <code>ctak</code> benchmark captures a continuation on every procedure call and throws a continuation on every return. In addition to <code>fibc</code> <code>loop2</code> and <code>ctak</code>, already used in <span class="citation">[<a href="#ref-Clinger1999">19</a>]</span>, I used a benchmark based on coroutines, and another implementing a generator.</p>
<p>I compared the modified version of Kawa with other Scheme implementations with an interpreter or JIT compiler, targeting either native machine code or an internal VM:</p>
<ul>
<li><p>Petite Chez Scheme is a sibling version of Chez Scheme, a proprietary Scheme implementation. Petite is a threaded interpreter and can be used free of charge.</p></li>
<li><p>Chicken is a Scheme to C compiler, but also an interpreter.</p></li>
<li><p>Gambit is a Scheme implementation, which has both and interpreter and a compiler that produces C code.</p></li>
<li><p>Guile is an interpreter and compiler for Scheme, using a virtual machine that executes a portable instruction set generated by its optimizing compiler, and integrates very easily with C and C++ application code.</p></li>
<li><p>Racket is a programming language based on standard Scheme, but includes way more features in the base language. It also offers an IDE and a large number of built in libraries and tools.</p></li>
<li><p>SISC is a Scheme interpreter written in Java, and running on the JVM. SISC is also the only other JVM Scheme supporting <code>call/cc</code>.</p></li>
</ul>
<div class="figure">
<img src="figures/interpreted-table.png" alt="Capturing benchmark (interpreted code), 10 iterations, values in seconds " />
<p class="caption">Capturing benchmark (interpreted code), 10 iterations, values in seconds </p>
</div>
<div class="figure">
<img src="figures/interpreted.png" alt="Capturing benchmark (interpreted code), 10 iterations " />
<p class="caption">Capturing benchmark (interpreted code), 10 iterations </p>
</div>
<p>Some of the Scheme implementations introduced above can pre-compile code to a bytecode or binary format, which can be later executed without paying the cost for translation. Figures  and  compares the execution time of code compiled by five compilers, including the modified version of Kawa.</p>
<div class="figure">
<img src="figures/compiled-table.png" alt="Capturing benchmark (pre-compiled code), 10 iterations, values in seconds " />
<p class="caption">Capturing benchmark (pre-compiled code), 10 iterations, values in seconds </p>
</div>
<div class="figure">
<img src="figures/compiled.png" alt="Capturing benchmark (pre-compiled code), 10 iterations " />
<p class="caption">Capturing benchmark (pre-compiled code), 10 iterations </p>
</div>
<p>Looking at the benchmarks' outcome we can see that Kawa with first-class continuations (Kawa fcc), despite the overhead we measured in the previous section, performs slightly better then SISC. As expected, Kawa fcc performances are far from the Scheme to C compilers, however, when compared with Guile and Racket they are within the same order of magnitude.</p>
<h2 id="callcc-memory-usage"><code>call/cc</code> memory usage</h2>
<p>I measured peak memory usage of the same five benchmarks introduced in the performance section, testing the same range of compilers. This time Kawa fcc performs similarly to SISC, except for the <code>fibc</code> benchmark. Kawa fcc also uses a similar amount of memory similar to Racket in the <code>coroutines</code>, <code>generators</code> and <code>ctak</code> benchmarks. Chez and Scheme to C compilers have performances unreachable for implementations using a VM, both in interpreted and compiled modes.</p>
<div class="figure">
<img src="figures/mem-interpreted-table.png" alt="Peak memory usage (interpreted code), 10 iterations, values in Kbytes " />
<p class="caption">Peak memory usage (interpreted code), 10 iterations, values in Kbytes </p>
</div>
<div class="figure">
<img src="figures/mem-interpreted.png" alt="Peak memory usage (interpreted code), 10 iterations " />
<p class="caption">Peak memory usage (interpreted code), 10 iterations </p>
</div>
<p>I repeated the same benchmarks using pre-compiled code. However, with relation to memory usage, the differences between interpreted vs compiled code is negligible.</p>
<div class="figure">
<img src="figures/mem-compiled-table.png" alt="Peak memory usage (pre-compiled code), 10 iterations, values in Kbytes " />
<p class="caption">Peak memory usage (pre-compiled code), 10 iterations, values in Kbytes </p>
</div>
<div class="figure">
<img src="figures/mem-compiled.png" alt="Peak memory usage (pre-compiled code), 10 iterations " />
<p class="caption">Peak memory usage (pre-compiled code), 10 iterations </p>
</div>
<h2 id="code-size-1">Code size</h2>
<p>We saw in Chapter 3 that we expect an increase in code size proportional to the number of code fragments, so we want to measure the actual difference in size between a regular class file and an instrumented one. Figure  shows a comparison of regular code and transformed code.</p>
<div class="figure">
<img src="figures/codesize-table.png" alt="Code size comparison, values in bytes " />
<p class="caption">Code size comparison, values in bytes </p>
</div>
<p>We can observe that the size of transformed code can be 10 times larger than the code compiled without first-class continuations enabled. Even if the code size increase is proportional to the number of fragments, the difference in size is significant. This indicates that would be better to limit the use of transformed code to modules that needs <code>call/cc</code>, and use <code>call/cc</code> enabled code in combination with non-transformed code.</p>
<div class="figure">
<img src="figures/codesize.png" alt="Size of compiled classes in bytes " />
<p class="caption">Size of compiled classes in bytes </p>
</div>
<h1 id="conclusions-and-future-work">Conclusions and future work</h1>
<p>This dissertation has presented an implementation of the <code>call/cc</code> control operator in Kawa, a Scheme compiler targeting the JVM. Although the problem was delineated in some works in literature, there was not a compiler providing first-class continuations on the JVM in terms of <code>call/cc</code>.</p>
<p>I developed a variant of generalised stack inspection in the Kawa compiler, addressing the problem of defining an A-normalisation algorithm for the Kawa super-set of Scheme, and realising a fragmentation and instrumentation pass using the existing Kawa framework. The whole transformation has been designed to be optional and separated from the existing passes, so that it does not add unnecessary overhead to modules without continuations.</p>
<p>I explored variations of the technique to implement other control operators, such as <code>shift</code>/<code>reset</code> and prompts, as well as continuation barriers. Moreover, the two passes are flexible enough that could be used on a portion of the syntax tree, instead of the entire program.</p>
<p>I showed the opportunities opened by the availability of <code>call/cc</code>, developing a syntax for asynchronous programming, and exploiting the A-normalisation of the syntax tree to create a simple debugger.</p>
<p>The evaluation of performance and memory usage revealed that this technique can be a valid alternative to heap-based implementations of <code>call/cc</code>. Benchmarks also showed that the bottleneck of the technique is not exception handling, but closure allocation, leaving room for improvement.</p>
<h2 id="future-work">Future work</h2>
<p>This work can be further developed in several interesting directions. I will outline a few possible applications and extensions, which can be based on this contribution to implement new features and obtain improvements in other programming languages or framework.</p>
<ul>
<li><p>Variants of this technique can be employed in other JVM languages to implement first-class delimited and un-delimited continuations and control operators. Languages like Clojure, JRuby, Groovy, Bigloo and others could take advantage of this work.</p></li>
<li><p>The transformation described in the previous pages uses an intermediate A-normalisation pass. ANF has been related in other works to Static Single Assignment (SSA) form <span class="citation">[<a href="#ref-Chakravarty2004">48</a>]</span>. It is possible to exploit the formal properties of ANF to implement in the compiler many optimisation present in literature.</p></li>
<li><p>In the past few years several frameworks for concurrency appeared on the Java scene. Many of them use bytecode instrumentation to implement coroutines and provide lightweight threads with low memory and task-switching overhead. Quasar <span class="citation">[<a href="#ref-QuasarAkka2015">49</a>]</span>, for instance, deliver the actor model on the JVM using bytecode instrumentation. The transformation presented in this document can give an alternative for those frameworks that aim to provide a concurrency API for Java or JVM languages.</p></li>
<li><p>Research has been done on the use of continuations in the context of web applications <span class="citation">[<a href="#ref-Matthews2004">50</a>, <a href="#ref-Queinnec2004">51</a>]</span>. The support for first-class continuations developed in the context of this thesis, can be utilised to implement continuation based web frameworks in Kawa or in Java.</p></li>
<li><p>The research field of Dynamic Software Updating (DSU) pertains to upgrading programs while they are running <span class="citation">[<a href="#ref-gregersen2014state">52</a>, <a href="#ref-Makris2009">53</a>]</span>. Different approaches for DSU has been developed, nevertheless it is not currently widely used in industry. Some of the approaches use a stack reconstruction technique similar in many aspects to the <code>call/cc</code> implementation described in this dissertation <span class="citation">[<a href="#ref-Buisson2008">54</a>]</span>. Future work can start from the achievements of this work to explore an alternative implementation of DSU on the JVM.</p></li>
</ul>
<p></p>
<div class="references">
<h1 id="references" class="unnumbered">References</h1>
<div id="ref-TurnConcurrency2015">
<p>[1] H. Sutter, “The Free Lunch Is Over: A Fundamental Turn Toward Concurrency in Software.” [Online]. Available: <a href="http://www.gotw.ca/publications/concurrency-ddj.htm" class="uri">http://www.gotw.ca/publications/concurrency-ddj.htm</a>. [Accessed: 14-Jun-2015]</p>
</div>
<div id="ref-TIOBEIndex2015">
<p>[2] “TIOBE Software: Tiobe Index.” [Online]. Available: <a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html" class="uri">http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html</a>. [Accessed: 11-Jun-2015]</p>
</div>
<div id="ref-JavaWiki2015">
<p>[3] “Java (programming language) - Wikipedia, the free encyclopedia.” [Online]. Available: <a href="https://en.wikipedia.org/wiki/Java_(programming_language)" class="uri">https://en.wikipedia.org/wiki/Java_(programming_language)</a>. [Accessed: 13-Jun-2015]</p>
</div>
<div id="ref-OracleLambda2015">
<p>[4] “Lambda Expressions (The Java™ Tutorials).” Oracle [Online]. Available: <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" class="uri">https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html</a>. [Accessed: 15-Jun-2015]</p>
</div>
<div id="ref-WhyLambda2013">
<p>[5] M. Fusco, “Why We Need Lambda Expressions in Java | Javalobby.” 27-Mar-2013 [Online]. Available: <a href="http://java.dzone.com/articles/why-we-need-lambda-expressions" class="uri">http://java.dzone.com/articles/why-we-need-lambda-expressions</a>. [Accessed: 13-Jun-2015]</p>
</div>
<div id="ref-JVMWiki2015">
<p>[6] “Java virtual machine - Wikipedia, the free encyclopedia.” [Online]. Available: <a href="https://en.wikipedia.org/wiki/Java_virtual_machine" class="uri">https://en.wikipedia.org/wiki/Java_virtual_machine</a>. [Accessed: 13-Jun-2015]</p>
</div>
<div id="ref-JVMLang2015">
<p>[7] “Alternative Languages for the JVM.” [Online]. Available: <a href="http://www.oracle.com/technetwork/articles/java/architect-languages-2266279.html" class="uri">http://www.oracle.com/technetwork/articles/java/architect-languages-2266279.html</a>. [Accessed: 14-Jun-2015]</p>
</div>
<div id="ref-SchemeWiki2015">
<p>[8] “Scheme (programming language) - Wikipedia, the free encyclopedia.” [Online]. Available: <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)" class="uri">https://en.wikipedia.org/wiki/Scheme_(programming_language)</a>. [Accessed: 15-Jun-2015]</p>
</div>
<div id="ref-dybvig2009scheme">
<p>[9] R. K. Dybvig, <em>The Scheme programming language, Fourth Edition</em>. 2009 [Online]. Available: <a href="http://www.scheme.com/tspl4/" class="uri">http://www.scheme.com/tspl4/</a></p>
</div>
<div id="ref-dybvig1987three">
<p>[10] R. K. Dybvig, “Three implementation models for scheme,” PhD thesis, University of North Carolina at Chapel Hill, 1987 [Online]. Available: <a href="http://www.cs.indiana.edu/~dyb/pubs/3imp.pdf" class="uri">http://www.cs.indiana.edu/~dyb/pubs/3imp.pdf</a></p>
</div>
<div id="ref-ContByExample2015">
<p>[11] M. Might, “Continuations by example.” [Online]. Available: <a href="http://goo.gl/ECRA5r" class="uri">http://goo.gl/ECRA5r</a>. [Accessed: 15-Jun-2015]</p>
</div>
<div id="ref-WhyContCool2015">
<p>[12] D. Martins, “Why Are Continuations So Darn Cool?” [Online]. Available: <a href="http://danielmartins.ninja/posts/why-are-continuations-so-darn-cool.html" class="uri">http://danielmartins.ninja/posts/why-are-continuations-so-darn-cool.html</a>. [Accessed: 15-Jun-2015]</p>
</div>
<div id="ref-PageCallcc2015">
<p>[13] D. Madore, “A page about call/cc.” [Online]. Available: <a href="http://www.madore.org/~david/computers/callcc.html" class="uri">http://www.madore.org/~david/computers/callcc.html</a>. [Accessed: 15-Jun-2015]</p>
</div>
<div id="ref-Asai2011">
<p>[14] K. Asai and O. Kiselyov, <em>Introduction to Programming with Shift and Reset</em>. 2011 [Online]. Available: <a href="http://www.is.ocha.ac.jp/~asai/cw2011tutorial/main-e.pdf" class="uri">http://www.is.ocha.ac.jp/~asai/cw2011tutorial/main-e.pdf</a></p>
</div>
<div id="ref-kiselyov2007delimited">
<p>[15] O. Kiselyov and C.-c. Shan, “Delimited continuations in operating systems,” in <em>Modeling and Using Context</em>, Springer, 2007, pp. 291–302 [Online]. Available: <a href="http://www.okmij.org/ftp/continuations/ZFS/context-OS.pdf" class="uri">http://www.okmij.org/ftp/continuations/ZFS/context-OS.pdf</a></p>
</div>
<div id="ref-RacketContinuations2015">
<p>[16] “Continuations - Racket Documentation.” [Online]. Available: <a href="http://docs.racket-lang.org/reference/cont.html#(part._.Classical_.Control_.Operators)" class="uri">http://docs.racket-lang.org/reference/cont.html#(part._.Classical_.Control_.Operators)</a>. [Accessed: 14-Jun-2015]</p>
</div>
<div id="ref-DelimitedWiki2015">
<p>[17] “Delimited continuation - Wikipedia, the free encyclopedia.” [Online]. Available: <a href="https://en.wikipedia.org/wiki/Delimited_continuation" class="uri">https://en.wikipedia.org/wiki/Delimited_continuation</a>. [Accessed: 14-Jun-2015]</p>
</div>
<div id="ref-Kawa2015">
<p>[18] “Kawa: The Kawa Scheme language.” [Online]. Available: <a href="http://www.gnu.org/software/kawa/index.html" class="uri">http://www.gnu.org/software/kawa/index.html</a>. [Accessed: 15-Jun-2015]</p>
</div>
<div id="ref-Clinger1999">
<p>[19] W. D. Clinger, A. H. Hartheimer, and E. M. Ost, “Implementation strategies for first-class continuations,” <em>Higher-Order and Symbolic Computation</em>, vol. 12, no. 1, pp. 7–45, 1999 [Online]. Available: <a href="http://link.springer.com/article/10.1023/A:1010016816429" class="uri">http://link.springer.com/article/10.1023/A:1010016816429</a></p>
</div>
<div id="ref-Miller2002">
<p>[20] S. G. Miller, “SISC: A complete scheme interpreter in java,” Technical Report, Jan, 2002 [Online]. Available: <a href="http://sisc-scheme.org/sisc.pdf" class="uri">http://sisc-scheme.org/sisc.pdf</a></p>
</div>
<div id="ref-appel2006compiling">
<p>[21] A. W. Appel, <em>Compiling with continuations</em>. Cambridge University Press, 2006. </p>
</div>
<div id="ref-adams1986orbit">
<p>[22] N. Adams, D. Kranz, R. Kelsey, J. Rees, P. Hudak, and J. Philbin, <em>Orbit: An optimizing compiler for Scheme</em>, vol. 21. ACM, 1986 [Online]. Available: <a href="http://dl.acm.org/citation.cfm?id=13333" class="uri">http://dl.acm.org/citation.cfm?id=13333</a></p>
</div>
<div id="ref-Rompf2009">
<p>[23] T. Rompf, I. Maier, and M. Odersky, “Implementing first-class polymorphic delimited continuations by a type-directed selective CPS-transform,” in <em>Proceedings of the 14th ACM SIGPLAN international conference on Functional programming - ICFP ’09</em>, 2009, p. 317 [Online]. Available: <a href="http://dl.acm.org/citation.cfm?doid=1596550.1596596" class="uri">http://dl.acm.org/citation.cfm?doid=1596550.1596596</a></p>
</div>
<div id="ref-McBeath2010">
<p>[24] J. McBeath, “Delimited Continuations.” August-2010 [Online]. Available: <a href="http://jim-mcbeath.blogspot.co.uk/2010/08/delimited-continuations.html" class="uri">http://jim-mcbeath.blogspot.co.uk/2010/08/delimited-continuations.html</a></p>
</div>
<div id="ref-Pettyjohn2005">
<p>[25] G. Pettyjohn, J. Clements, J. Marshall, S. Krishnamurthi, and M. Felleisen, “Continuations from generalized stack inspection,” in <em>Proceedings of the tenth ACM SIGPLAN international conference on Functional programming - ICFP ’05</em>, 2005, p. 216 [Online]. Available: <a href="http://portal.acm.org/citation.cfm?doid=1086365.1086393" class="uri">http://portal.acm.org/citation.cfm?doid=1086365.1086393</a></p>
</div>
<div id="ref-Sekiguchi2001">
<p>[26] T. Sekiguchi, T. Sakamoto, and A. Yonezawa, “Advances in Exception Handling Techniques,” A. Romanovsky, C. Dony, J. L. Knudsen, and A. Tripathi, Eds. Springer Berlin Heidelberg, 2001, pp. 217–233 [Online]. Available: <a href="http://dx.doi.org/10.1007/3-540-45407-1_14" class="uri">http://dx.doi.org/10.1007/3-540-45407-1_14</a></p>
</div>
<div id="ref-tao2001portable">
<p>[27] W. Tao, “A portable mechanism for thread persistence and migration,” PhD thesis, School of Computing, University of Utah, 2001 [Online]. Available: <a href="http://www.cs.utah.edu/~tao/research/" class="uri">http://www.cs.utah.edu/~tao/research/</a></p>
</div>
<div id="ref-Loitsch2007">
<p>[28] F. Loitsch, <em>Exceptional continuations in JavaScript</em>. 2007 [Online]. Available: <a href="http://repository.readscheme.org/ftp/papers/sw2007/04-loitsch.pdf" class="uri">http://repository.readscheme.org/ftp/papers/sw2007/04-loitsch.pdf</a></p>
</div>
<div id="ref-Marshall2009">
<p>[29] J. Marshall, “An Unexceptional Implementation of First-Class Continuations,” in <em>Proceedings of the 2009 International Lisp Conference</em>, 2009, pp. 36–40 [Online]. Available: <a href="https://drive.google.com/file/d/0B4zj6rF-PmISMTNjYWVhYmYtZTQ1MC00YTg4LWFiYTQtYzJiZjQwMzQyMjA1/view?ddrp=1&amp;hl=en" class="uri">https://drive.google.com/file/d/0B4zj6rF-PmISMTNjYWVhYmYtZTQ1MC00YTg4LWFiYTQtYzJiZjQwMzQyMjA1/view?ddrp=1&amp;hl=en</a></p>
</div>
<div id="ref-Srinivasan2006">
<p>[30] S. Srinivasan, <em>A thread of one’s own</em>, vol. 4. 2006 [Online]. Available: <a href="http://malhar.net/sriram/kilim/thread_of_ones_own.pdf" class="uri">http://malhar.net/sriram/kilim/thread_of_ones_own.pdf</a></p>
</div>
<div id="ref-Bolton2000">
<p>[31] L. Bolton, “Kilim: a server framework with lightweight actors, isolation types, and zero-copy messaging,” <em>The Contemporary Pacific</em>, vol. 12, no. 2, pp. 561–563, 2000 [Online]. Available: <a href="http://muse.jhu.edu/content/crossref/journals/contemporary\_pacific/v012/12.2bolton.html" class="uri">http://muse.jhu.edu/content/crossref/journals/contemporary\_pacific/v012/12.2bolton.html</a></p>
</div>
<div id="ref-StackHack2005">
<p>[32] G. Pettyjohn, J. Clements, J. Marshall, S. Krishnamurthi, and M. Felleisen, “A Technique for Implementing First-Class Continuations.” 2005 [Online]. Available: <a href="http://www.ccs.neu.edu/racket/pubs/stackhack4.html" class="uri">http://www.ccs.neu.edu/racket/pubs/stackhack4.html</a></p>
</div>
<div id="ref-Longjumps2015">
<p>[33] J. Rose, “Longjumps Considered Inexpensive.” 10-May-2007 [Online]. Available: <a href="https://blogs.oracle.com/jrose/entry/longjumps_considered_inexpensive" class="uri">https://blogs.oracle.com/jrose/entry/longjumps_considered_inexpensive</a>. [Accessed: 09-Jun-2015]</p>
</div>
<div id="ref-Flanagan1993">
<p>[34] C. Flanagan, A. Sabry, B. F. Duba, and M. Felleisen, “The essence of compiling with continuations,” in <em>Proceedings of the ACM SIGPLAN 1993 conference on Programming language design and implementation - PLDI ’93</em>, 1993, pp. 237–247 [Online]. Available: <a href="http://portal.acm.org/citation.cfm?doid=155090.155113" class="uri">http://portal.acm.org/citation.cfm?doid=155090.155113</a></p>
</div>
<div id="ref-Javaflow2015">
<p>[35] “Commons Javaflow - Overview.” [Online]. Available: <a href="http://commons.apache.org/sandbox/commons-javaflow/" class="uri">http://commons.apache.org/sandbox/commons-javaflow/</a>. [Accessed: 09-Jun-2015]</p>
</div>
<div id="ref-Stadler2009">
<p>[36] L. Stadler, C. Wimmer, T. Würthinger, H. Mössenböck, and J. Rose, “Lazy continuations for Java virtual machines,” in <em>Proceedings of the 7th International Conference on Principles and Practice of Programming in Java - PPPJ ’09</em>, 2009, p. 143 [Online]. Available: <a href="http://portal.acm.org/citation.cfm?doid=1596655.1596679" class="uri">http://portal.acm.org/citation.cfm?doid=1596655.1596679</a></p>
</div>
<div id="ref-RIFE2015">
<p>[37] “RIFE : About.” [Online]. Available: <a href="http://rifers.org/" class="uri">http://rifers.org/</a>. [Accessed: 09-Jun-2015]</p>
</div>
<div id="ref-begel2000picothreads">
<p>[38] A. Begel, J. MacDonald, and M. Shilman, “PicoThreads: Lightweight threads in Java,” <em>Department of Electrical Engineering &amp; Computer Sciences University of California, Berkeley</em>, 2000 [Online]. Available: <a href="http://research.microsoft.com/en-us/um/people/abegel/cs262/picothreads.pdf" class="uri">http://research.microsoft.com/en-us/um/people/abegel/cs262/picothreads.pdf</a></p>
</div>
<div id="ref-ContinuationsLib2015">
<p>[39] M. Mann, “Continuations Library.” [Online]. Available: <a href="http://www.matthiasmann.de/content/view/24/26/" class="uri">http://www.matthiasmann.de/content/view/24/26/</a>. [Accessed: 09-Jun-2015]</p>
</div>
<div id="ref-Bothner1998">
<p>[40] P. Bothner, “Kawa internals: Compiling Scheme to Java.” 17-November-1998 [Online]. Available: <a href="http://www.gnu.org/software/kawa/internals/index.html" class="uri">http://www.gnu.org/software/kawa/internals/index.html</a></p>
</div>
<div id="ref-ANFMight2015">
<p>[41] M. Might, “A-Normalization: Why and How.” [Online]. Available: <a href="http://matt.might.net/articles/a-normalization/" class="uri">http://matt.might.net/articles/a-normalization/</a>. [Accessed: 17-Jun-2015]</p>
</div>
<div id="ref-jmh2015">
<p>[42] “OpenJDK: jmh.” [Online]. Available: <a href="http://openjdk.java.net/projects/code-tools/jmh/" class="uri">http://openjdk.java.net/projects/code-tools/jmh/</a>. [Accessed: 23-Jun-2015]</p>
</div>
<div id="ref-BenchmarkingJVM2015">
<p>[43] J. Ponge, “Avoiding Benchmarking Pitfalls on the JVM.” [Online]. Available: <a href="http://www.oracle.com/technetwork/articles/java/architect-benchmarking-2266277.html" class="uri">http://www.oracle.com/technetwork/articles/java/architect-benchmarking-2266277.html</a>. [Accessed: 23-Jun-2015]</p>
</div>
<div id="ref-EvaluationRacket2015">
<p>[44] “1.1 Evaluation Model.” [Online]. Available: <a href="http://docs.racket-lang.org/reference/eval-model.html#%28part._prompt-model%29">http://docs.racket-lang.org/reference/eval-model.html#%28part._prompt-model%29</a>. [Accessed: 28-Jun-2015]</p>
</div>
<div id="ref-Filinski1994">
<p>[45] A. Filinski, “Representing monads,” in <em>Proceedings of the 21st ACM SIGPLAN-SIGACT symposium on Principles of programming languages - POPL ’94</em>, 1994, pp. 446–457 [Online]. Available: <a href="http://portal.acm.org/citation.cfm?doid=174675.178047" class="uri">http://portal.acm.org/citation.cfm?doid=174675.178047</a></p>
</div>
<div id="ref-biagioni1998safe">
<p>[46] E. Biagioni, K. Cline, P. Lee, C. Okasaki, and C. Stone, “Safe-for-space threads in Standard ML,” <em>Higher-Order and Symbolic Computation</em>, vol. 11, no. 2, pp. 209–225, 1998 [Online]. Available: <a href="http://link.springer.com/article/10.1023/A:1010016600604" class="uri">http://link.springer.com/article/10.1023/A:1010016600604</a></p>
</div>
<div id="ref-HPROF2015">
<p>[47] “HPROF: A Heap/CPU Profiling Tool.” Oracle [Online]. Available: <a href="http://docs.oracle.com/javase/8/docs/technotes/samples/hprof.html" class="uri">http://docs.oracle.com/javase/8/docs/technotes/samples/hprof.html</a>. [Accessed: 26-Jun-2015]</p>
</div>
<div id="ref-Chakravarty2004">
<p>[48] M. M. Chakravarty, G. Keller, and P. Zadarnowski, “A Functional Perspective on SSA Optimisation Algorithms,” <em>Electronic Notes in Theoretical Computer Science</em>, vol. 82, no. 2, pp. 347–361, Apr 2004 [Online]. Available: <a href="http://dx.doi.org/10.1016/S1571-0661(05)82596-4" class="uri">http://dx.doi.org/10.1016/S1571-0661(05)82596-4</a></p>
</div>
<div id="ref-QuasarAkka2015">
<p>[49] “Parallel Universe.” Parallel Universe [Online]. Available: <a href="http://blog.paralleluniverse.co/2015/05/21/quasar-vs-akka/" class="uri">http://blog.paralleluniverse.co/2015/05/21/quasar-vs-akka/</a>. [Accessed: 29-Jun-2015]</p>
</div>
<div id="ref-Matthews2004">
<p>[50] J. Matthews, R. B. Findler, P. Graunke, S. Krishnamurthi, and M. Felleisen, “Automatically Restructuring Programs for the Web,” <em>Automated Software Engineering</em>, vol. 11, no. 4, pp. 337–364, Oct 2004 [Online]. Available: <a href="http://dx.doi.org/10.1023/B:AUSE.0000038936.09009.69" class="uri">http://dx.doi.org/10.1023/B:AUSE.0000038936.09009.69</a></p>
</div>
<div id="ref-Queinnec2004">
<p>[51] C. Queinnec, “Continuations and Web Servers,” vol. 17, no. 4, pp. 277–295, Dec 2004 [Online]. Available: <a href="http://dx.doi.org/10.1007/s10990-004-4866-z" class="uri">http://dx.doi.org/10.1007/s10990-004-4866-z</a></p>
</div>
<div id="ref-gregersen2014state">
<p>[52] A. R. Gregersen, M. Rasmussen, and B. N. Jørgensen, “State of the Art of Dynamic Software Updating in Java,” in <em>Software Technologies</em>, Springer, 2014, pp. 99–113 [Online]. Available: <a href="http://link.springer.com/chapter/10.1007%2F978-3-662-44920-2_7">http://link.springer.com/chapter/10.1007%2F978-3-662-44920-2_7</a></p>
</div>
<div id="ref-Makris2009">
<p>[53] K. Makris and R. A. Bazzi, <em>Immediate Multi-Threaded Dynamic Software Updates Using Stack Reconstruction.</em>, vol. 2009. 2009 [Online]. Available: <a href="http://static.usenix.org/legacy/events/usenix09/tech/full_papers/makris/makris.pdf" class="uri">http://static.usenix.org/legacy/events/usenix09/tech/full_papers/makris/makris.pdf</a></p>
</div>
<div id="ref-Buisson2008">
<p>[54] J. Buisson and F. Dagnat, “Introspecting continuations in order to update active code,” in <em>Proceedings of the 1st International Workshop on Hot Topics in Software Upgrades - HotSWUp ’08</em>, 2008, p. 1 [Online]. Available: <a href="http://portal.acm.org/citation.cfm?doid=1490283.1490289" class="uri">http://portal.acm.org/citation.cfm?doid=1490283.1490289</a></p>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>For more explanation and examples on continuations see <span class="citation">[<a href="#ref-ContByExample2015">11</a>–<a href="#ref-PageCallcc2015">13</a>]</span>.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
</body>
</html>
